functionality needed
	fast loading time
	low memory footprint
	offline notes
	compressed audio
	checkboxes
	folder tracking
	snapshot sizing
	search
		EN has its own search facility
			only available online
		specifications are available
			so it could be implemented offline also
		sorting
original main screen buttons
	text note
	ink note
	snapshot
	audio note
	upload file
tech needed
	UI
		HTMLayout
	DTD checking
		only needed for testing
	THTTP
	ENML XML->HTML convertion
		TinyXML
		pugixml
		RapidXML
need to figure out the overall design
	highest level features
		view notes
			subsets of notes
			with sorting
		create notes
			text at first
			photo, ink, audio, files later
		modify todo notes
			by checking/unchecking
		find notes
		switch notebooks
		sync
	required functionality
		UI to view a set of notes
		UI to view a note
		UI to choose a method of note creation
		note creation UI
		note storage and retrieval
		note synchronization
	runtime design
		load main UI first
		delay-load the remaining functionality
		nah, not until profiling shows it to be a bottleneck
	UI design
		log in
			get username and password
			go to the main screen
			action
				OK/Cancel
		main screen
			create notes
			action
				Notes
			menu
				About
				Logout
				Exit
		notes view
			shows most recent notes
			options
				search
				sort
					HTMLayoutSortElements
				reset
			actions
				New note/Sync
		sync
			collapsible
			list sync events
				status
				progress
		soft keys
			neither the main screen nor notes view have main actions
			I could make a single screen
				with the following elements
					notes list
					new note popout
					synchronization indicator
					search box
					sort popout
			however, showing the new note screen is much faster
				more optimized for starting quickly
				less optimized for coninuous use
			how to place the elements
				search box at the top
				notes list has to take as much space as possible
				have to be on the bottom
				as buttons with text, like EN iPhone
					Create Note
					Sort by <order>
					Sync
				bad idea
				make Sync the default action
				make note creation a fake first note
				make sort/filter menu options
		new screens
			sign in
				username/password and link to evernote.com
				soft keys
					Sign in
					Cancel
			notes list
				notes list, search, creation
				soft keys
					Sync
					Menu
						Sign out
						Notebook
						About
						Exit
			note view
				note contents, prev/next navigation
				soft keys
					Notes
			note creation
				soft keys
					OK
					Cancel
			about
				branding, version, author, date
				soft keys
					OK
	data storage design
		store notes and settings
		EN has a flat data model
		so, we can make tables directly from structs
		unsynced notes
			should be stored with the rest
			but marked as asynced
		at sync
			query the database for unsynced notes
			replace them with synced ones received from the server
		full-text search
			provided by the FTS3 extension of SQLite
			used by the Windows EN client
	synchronization design
		sync is comprised of several tasks
			download new server notes
				getSyncState/getSyncChunk/getNoteContent/getResourceData
				resolve conflicts
			upload new local notes
				the server provides replacements for the local notes
				resolve conflicts
		sync connections
			USB always
			9G never
			WiFi probably
		manual sync
			needed for searching server notes
			uploading local notes
			either way, it is only needed in the notes screen
		fault tolerance
			downloading notes
				via SQLite transactions
			uploading notes
				create a log before uploading
				clear it on success
				try to repeat on failure
		need to show the user when sync is required
			how many unsynced messages he has
			this calls for a button, instead of the soft key
				not really
				could add a number to the soft key title
	program structure
		MVP - Presenter First
			DB and registry are the model
			the windows are the views with controllers attached
		main window is not always needed
			not when there is no user signed in
		who desides which windows are created when?
			some sort of overlord state machine
			created at startup
			decides which windows to show
			receives messages from these windows
			changes window states
		there should be a flat stateless core
			with heavy-duty functions called by the controllers
	user credentials
		CryptProtectData/CryptUnprotectData
	EN connection
		through credentials verification
			get AuthenticationToken from EN
		through note sync
			upload/download notes and resources
program start
	sounds like an event
	when the program starts with a user, his notes are displayed
		and his credentials not authenticated
		meaning, that valid credentials are not needed
		the user is, then, separate from credentials
	there should be a user model, then, with credentials and notebooks
	when the program starts without a user, a default user is created
		with empty credentials
		which are, obviously, invalid
		and an empty notebook
	what should happen
		the last active user is retrieved from the registry
			default user assumed
		the user's database is loaded
			if no database is present
				create one
				with an empty default notebook
			if loading fails
				go to sign in with the error message
		the list of notes is retreived
			from the last active notebook
		the list of notes is displayed
NoteListView
	displays notes
		NoteListModel
	performs searches
		affects NoteListModel
		but indirectly
		since the search is within the current notebook
	lists notebooks
		UserModel
	displaying notes requires creation of HTML code and HTMLayout handling
		created from an internal format
		which should be as close to Evernote's as possible
		preferably, Evernote's format
			seems usable for internal representation
			better yet, create a note interface
			the real one will delegate to EN Note
			the mock one will do something else
		sounds like the problem in the paper
			they created an adapter that converted data
			but my problem is simpler
			merely one-way encoding
		streaming
			no need to encode all at once
			HTMLayout will need one DOM element at a time
				then, a mass update
	creation
		should be created before loading notes
			before the user is loaded
		so, the user should be loaded in responce to window being created
		create separate events for starting the UI and starting the model
			no, the app does not know when the window is created
			it should return to the message loop first
asynchronous start
	the model should not be loaded on the UI thread
	UI should be created first
		then the message loop should start running
		then the model should start loading on a separate thread
	everything is connected in advance
	so to start loading on another thread, a signal has to be made on another thread
asynchronous sync
	could be done using a worker thread
AppModel
	maybe, it is entirely redundant
	before the message loop starts
		everything needs to be connected
		and the main window needs to be created
	everything else should start in response to main window creation
		after the message loop starts running
	PostQuitMessage is a good way to terminate
lock hierarchy
	UI runs on its own thread
	UI also starts other threads
		loading data
		sync
	UI does not access other objects directly
		because it a view
	UI signals should not block
		because they return nothing
		however, they do signal user intent
		which might warrant some immediate UI changes
		so, it is not the view that decides on threading
	which non-UI operations should be serial?
		operations on any one model, obviously
		note list and a notebook could be modified simulatneously
			to search while syncing
			except for copying from the notebook to the note list
	solution
		model-wide locks
		only call getters while holding a lock
		do not make signals from getters

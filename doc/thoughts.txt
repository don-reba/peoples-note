functionality needed
	fast loading time
	low memory footprint
	offline notes
	compressed audio
	checkboxes
	folder tracking
	snapshot sizing
	search
		EN has its own search facility
			only available online
		specifications are available
			so it could be implemented offline also
		sorting
original main screen buttons
	text note
	ink note
	snapshot
	audio note
	upload file
tech needed
	UI
		HTMLayout
	DTD checking
		only needed for testing
	THTTP
	ENML XML->HTML convertion
		TinyXML
		pugixml
		RapidXML
need to figure out the overall design
	highest level features
		view notes
			subsets of notes
			with sorting
		create notes
			text at first
			photo, ink, audio, files later
		modify todo notes
			by checking/unchecking
		find notes
		switch notebooks
		sync
	required functionality
		UI to view a set of notes
		UI to view a note
		UI to choose a method of note creation
		note creation UI
		note storage and retrieval
		note synchronization
	runtime design
		load main UI first
		delay-load the remaining functionality
		nah, not until profiling shows it to be a bottleneck
	UI design
		log in
			get username and password
			go to the main screen
			action
				OK/Cancel
		main screen
			create notes
			action
				Notes
			menu
				About
				Logout
				Exit
		notes view
			shows most recent notes
			options
				search
				sort
					HTMLayoutSortElements
				reset
			actions
				New note/Sync
		sync
			collapsible
			list sync events
				status
				progress
		soft keys
			neither the main screen nor notes view have main actions
			I could make a single screen
				with the following elements
					notes list
					new note popout
					synchronization indicator
					search box
					sort popout
			however, showing the new note screen is much faster
				more optimized for starting quickly
				less optimized for coninuous use
			how to place the elements
				search box at the top
				notes list has to take as much space as possible
				have to be on the bottom
				as buttons with text, like EN iPhone
					Create Note
					Sort by <order>
					Sync
				bad idea
				make Sync the default action
				make note creation a fake first note
				make sort/filter menu options
		new screens
			sign in
				username/password and link to evernote.com
				soft keys
					Sign in
					Cancel
			notes list
				notes list, search, creation
				soft keys
					Sync
					Menu
						Sign out
						Notebook
						About
						Exit
			note view
				note contents, prev/next navigation
				soft keys
					Notes
			note creation
				soft keys
					OK
					Cancel
			about
				branding, version, author, date
				soft keys
					OK
	data storage design
		store notes and settings
		EN has a flat data model
		so, we can make tables directly from structs
		unsynced notes
			should be stored with the rest
			but marked as asynced
		at sync
			query the database for unsynced notes
			replace them with synced ones received from the server
		full-text search
			provided by the FTS3 extension of SQLite
			used by the Windows EN client
	synchronization design
		sync is comprised of several tasks
			download new server notes
				getSyncState/getSyncChunk/getNoteContent/getResourceData
				resolve conflicts
			upload new local notes
				the server provides replacements for the local notes
				resolve conflicts
		sync connections
			USB always
			9G never
			WiFi probably
		manual sync
			needed for searching server notes
			uploading local notes
			either way, it is only needed in the notes screen
		fault tolerance
			downloading notes
				via SQLite transactions
			uploading notes
				create a log before uploading
				clear it on success
				try to repeat on failure
		need to show the user when sync is required
			how many unsynced messages he has
			this calls for a button, instead of the soft key
				not really
				could add a number to the soft key title
	program structure
		MVP - Presenter First
			DB and registry are the model
			the windows are the views with controllers attached
		main window is not always needed
			not when there is no user signed in
		who desides which windows are created when?
			some sort of overlord state machine
			created at startup
			decides which windows to show
			receives messages from these windows
			changes window states
		there should be a flat stateless core
			with heavy-duty functions called by the controllers
	user credentials
		CryptProtectData/CryptUnprotectData
	EN connection
		through credentials verification
			get AuthenticationToken from EN
		through note sync
			upload/download notes and resources
program start
	sounds like an event
	when the program starts with a user, his notes are displayed
		and his credentials not authenticated
		meaning, that valid credentials are not needed
		the user is, then, separate from credentials
	there should be a user model, then, with credentials and notebooks
	when the program starts without a user, a default user is created
		with empty credentials
		which are, obviously, invalid
		and an empty notebook
	what should happen
		the last active user is retrieved from the registry
			default user assumed
		the user's database is loaded
			if no database is present
				create one
				with an empty default notebook
			if loading fails
				go to sign in with the error message
		the list of notes is retreived
			from the last active notebook
		the list of notes is displayed
NoteListView
	displays notes
		NoteListModel
	performs searches
		affects NoteListModel
		but indirectly
		since the search is within the current notebook
	lists notebooks
		UserModel
	displaying notes requires creation of HTML code and HTMLayout handling
		created from an internal format
		which should be as close to Evernote's as possible
		preferably, Evernote's format
			seems usable for internal representation
			better yet, create a note interface
			the real one will delegate to EN Note
				cache to allow access to members through interface
			the mock one will do something else
			nah, better convert on sync
		sounds like the problem in the paper
			they created an adapter that converted data
			but my problem is simpler
			merely one-way encoding
		streaming
			no need to encode all at once
			HTMLayout will need one DOM element at a time
				then, a mass update
	creation
		should be created before loading notes
			before the user is loaded
		so, the user should be loaded in responce to window being created
		create separate events for starting the UI and starting the model
			no, the app does not know when the window is created
			it should return to the message loop first
asynchronous start
	the model should not be loaded on the UI thread
	UI should be created first
		then the message loop should start running
		then the model should start loading on a separate thread
	everything is connected in advance
	so to start loading on another thread, a signal has to be made on another thread
asynchronous sync
	could be done using a worker thread
AppModel
	maybe, it is entirely redundant
	before the message loop starts
		everything needs to be connected
		and the main window needs to be created
	everything else should start in response to main window creation
		after the message loop starts running
	PostQuitMessage is a good way to terminate
lock hierarchy
	UI runs on its own thread
	UI also starts other threads
		loading data
		sync
	UI does not access other objects directly
		because it a view
	UI signals should not block
		because they return nothing
		however, they do signal user intent
		which might warrant some immediate UI changes
		so, it is not the view that decides on threading
	which non-UI operations should be serial?
		operations on any one model, obviously
		note list and a notebook could be modified simulatneously
			to search while syncing
			except for copying from the notebook to the note list
	solution
		model-wide locks
		only call getters while holding a lock
			everything that is called is called inside some lock
			so this condition makes no sense
		do not make signals from getters
		need another solution
database
	access should be encapsulated
		a separate class should return data from the database
			notes
			notebooks
			tags
			user data
		notebooks should not store notes
		but notes could still be accessed through notebooks
			notebooks could have references to the user model
			which would manage store and cache
		the alternative is to pass notebooks to user model
			which is awkward
	caching should be explicit
		caching policy should be flexible
		consumers should not know what is cached
	who should query the database
		UserModel should return ready-to-use data
		this data can come from cache or store
		UserModel has little other logic
		so let it do it
	editing
		edited notes have to be synced
			replaced with EN's versions
		editing needs to be fluid
			reloading note list bad option
		solution
			edit in-place
			signal editing complete
			notify UserModel
			mark the note for sync
			have UserModel signal note update
HTMLayout event handling
	alternatives
		process events within window
			- need a map indexed by two values
		create element behaviors
			- writing a class to foward a cilck
			- event switch
			+ easier attachment
HTMLayout resource loading
	by name
	maybe they could all be classified as HTML
sync with Evernote
	can implement sending by email at first
forward declarations
	should be made for interfaces in headers
		done
note access
	most data transformation should be done by data access layer
	data requests
		get a page of notes in a notebook
			filtered by keywords
			filtered by tags
			filtered by creation date
		get next page of notes
		get previous page of notes
		get a note
		get previous note
		get next note
	EN search grammar is non-recursive
	in the end, request becomes an SQL query
		same kind of filter can be combined
	solutions
		specialized functions, like GetNotesByNotebook
		generic function; client provides filters
			- verbose for simple queries
			- difficult to cache
data modification
	is database access is single-threaded?
		sync via separate connection
			can sync read/write data in one go?
			no, there can be long delays and conflicts
		wait, is it really single-threaded?
		loading notes might be time-consuming
		blocking UI for that period of time might be bad
			insead, disable some UI elements
			create a worker thread for creating the element HTML
			block UI to add one ready HTML at a time
			can be aborted
		so, data for HTML creation is loaded by a worker thread
			only one of these can exist at a time
		can other threads access the database?
			these threads would not be modifying or querying notes
			modify some other data?
				notebook name
		SQLite has three modes
			single-threaded: only one thread
			multi-threaded: one thread per connection
			serialized: multiple threads per connection
		target multi-threaded mode
	database access from sync thread and ui thread
	ui thread and ui data thread are different threads
		ui thread
			processes messages
			enqueues data tasks
		data thread
			executes data tasks
			sends messages to ui thread
	so, what happens when the user enters a new note title?
		ui thread asks data thread to make the modification
		data thead comits the modification transactionally
		data thread notifies ui thread of completion
		ui thread changes the note title
	GUI is only modified in response to window messages
	view classes can have setter methods
		if they do not modify GUI
			therefore, can be called from other threads
		also, if they do modify GUI
			these methods post window messages
	should there be different db models for sync and processing?
		no, they return the same data types
	should there be different db instances for sync and processing?
		each instance with its own connection
		each with its own caching, if needed
		seems like a good idea
	so, how should last used notebook be returned?
		stored as a name-value pair
		db passes a notebook object to the user model
		the user model passes it to the presenter
		the presenter processes it
		maybe creates some new object for a view
		the point is, db access is single-threaded
		so the database can return a pointer
			there is always at least one notebook
			there is always a default notebook
			the pointer should never be null
		if the pointer is never null, it can be a reference
		the class member can be a pointer
			assert not null before returning the reference
threading
	I don't want to implement threading right away
	but threading should be easy to add later on
	the threading model is dictated by sqlite and htmlayout
	each db instance represents a db connection
	access to each db instance is single-threaded
	all ui should be single-threaded
	we therefore have a ui thread and a thread per db instance
	ui thread
		signals from ui create data thread tasks
			presenters handles this
		ui getters send messages
			ui handles this
			sending on the same thread does not lock
			signal handlers from data threads should avoid getters
		ui setters post messages
			ui handles this
	data thread
		one per db instance
		should then be implemented in the db
		the db should have a message pump
	want to avoid bothering with messaging and tasks for now
database
	when should it be initialized?
		when it is being created
			check if the database is empty
			check for the properties table
		in future, when converting an old format
	how should it be initialized?
		assuming it is empty
		create tables
			properties
				version
				user name
				last used notebook
				default notebook
			notes
mobile testing
	need simple alternative to boost::test
	can copy stuff
	how can I implement AUTO_TEST_CASE?
		create a function taking a Test parameter
		add a pointer to the function to some global list
			how?
		create a base that adds itself to the global list on construction
		create test case classes that inherit from the base
		create a static instance of every such class
identity
	notebooks are identified by GUID
		but also have unique names
	unsynced notebooks have no GUID
	therefore, names are the real identifier
	what about notes?
	they don't have unique names
	when I want to open a note, a have to refer to it by some id
		by GUID
	therefore, notes need to have GUIDs
	maybe notebooks should have GUIDs too, then
	they can be assigned GUIDs automatically between syncs
	these would be replaced by server's GUIDs after sync
		views would have to be updated after sync completes
	also, the DOM elements need a GUID attribute
sync update
	GUIDs change after sync
		and possibly other fields
	if the note list is being displayed
		the query should be repeated
	if a note is being displayed
		it should be fetched from the database again
		deleted if absent
		but how, if it's GUID is old
		need a map from old GUIDs to new
	if a note is being edited
		TODO
mobile testing exceptions
	are often not caught
		TODO
	also need to test for exceptions
		TODO
mobile testing fixtures
	setting up the database every time is taking up space
	need two different classes
		global one to register the test
		local one to be created with a  fixture
UTF8 strings
	vector<unsigned char> is a bad container
	can't get a pointer when empty
	TODO
data store initialization
	sqlite3_open_v2 creates a database that is either
		has no version
		has lesser version
		has greater version
		has correct version
	it is better not to try handling invalid databases
		what about db creation errors?
			TODO
note import
	EnImporter needs to allocate notes
	no need to have them live outside OnImport handler
	options
		create EnImporter locally
			- can't use an interface, then
		have EnImporter use outside storage
			- different from DataStore
				maybe DataStore is the one that needs to change
				if it does not want notes to live between calls
		make EnImport clear its memory
			- extra call; might forget

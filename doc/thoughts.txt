functionality needed
	fast loading time
	low memory footprint
	offline notes
	compressed audio
	checkboxes
	folder tracking
	snapshot sizing
	search
		EN has its own search facility
			only available online
		specifications are available
			so it could be implemented offline also
		sorting
original main screen buttons
	text note
	ink note
	snapshot
	audio note
	upload file
tech needed
	UI
		HTMLayout
	DTD checking
		only needed for testing
	THTTP
	ENML XML->HTML convertion
		TinyXML
		pugixml
		RapidXML
need to figure out the overall design
	highest level features
		view notes
			subsets of notes
			with sorting
		create notes
			text at first
			photo, ink, audio, files later
		modify todo notes
			by checking/unchecking
		find notes
		switch notebooks
		sync
	required functionality
		UI to view a set of notes
		UI to view a note
		UI to choose a method of note creation
		note creation UI
		note storage and retrieval
		note synchronization
	runtime design
		load main UI first
		delay-load the remaining functionality
		nah, not until profiling shows it to be a bottleneck
	UI design
		log in
			get username and password
			go to the main screen
			action
				OK/Cancel
		main screen
			create notes
			action
				Notes
			menu
				About
				Logout
				Exit
		notes view
			shows most recent notes
			options
				search
				sort
					HTMLayoutSortElements
				reset
			actions
				New note/Sync
		sync
			collapsible
			list sync events
				status
				progress
		soft keys
			neither the main screen nor notes view have main actions
			I could make a single screen
				with the following elements
					notes list
					new note popout
					synchronization indicator
					search box
					sort popout
			however, showing the new note screen is much faster
				more optimized for starting quickly
				less optimized for coninuous use
			how to place the elements
				search box at the top
				notes list has to take as much space as possible
				have to be on the bottom
				as buttons with text, like EN iPhone
					Create Note
					Sort by <order>
					Sync
				bad idea
				make Sync the default action
				make note creation a fake first note
				make sort/filter menu options
		new screens
			sign in
				username/password and link to evernote.com
				soft keys
					Sign in
					Cancel
			notes list
				notes list, search, creation
				soft keys
					Sync
					Menu
						Sign out
						Notebook
						About
						Exit
			note view
				note contents, prev/next navigation
				soft keys
					Notes
			note creation
				soft keys
					OK
					Cancel
			about
				branding, version, author, date
				soft keys
					OK
	data storage design
		store notes and settings
		EN has a flat data model
		so, we can make tables directly from structs
		unsynced notes
			should be stored with the rest
			but marked as asynced
		at sync
			query the database for unsynced notes
			replace them with synced ones received from the server
		full-text search
			provided by the FTS3 extension of SQLite
			used by the Windows EN client
	synchronization design
		sync is comprised of several tasks
			download new server notes
				getSyncState/getSyncChunk/getNoteContent/getResourceData
				resolve conflicts
			upload new local notes
				the server provides replacements for the local notes
				resolve conflicts
		sync connections
			USB always
			9G never
			WiFi probably
		manual sync
			needed for searching server notes
			uploading local notes
			either way, it is only needed in the notes screen
		fault tolerance
			downloading notes
				via SQLite transactions
			uploading notes
				create a log before uploading
				clear it on success
				try to repeat on failure
		need to show the user when sync is required
			how many unsynced messages he has
			this calls for a button, instead of the soft key
				not really
				could add a number to the soft key title
	program structure
		MVP - Presenter First
			DB and registry are the model
			the windows are the views with controllers attached
		main window is not always needed
			not when there is no user signed in
		who desides which windows are created when?
			some sort of overlord state machine
			created at startup
			decides which windows to show
			receives messages from these windows
			changes window states
		there should be a flat stateless core
			with heavy-duty functions called by the controllers
	user credentials
		CryptProtectData/CryptUnprotectData
	EN connection
		through credentials verification
			get AuthenticationToken from EN
		through note sync
			upload/download notes and resources
program start
	sounds like an event
	when the program starts with a user, his notes are displayed
		and his credentials not authenticated
		meaning, that valid credentials are not needed
		the user is, then, separate from credentials
	there should be a user model, then, with credentials and notebooks
	when the program starts without a user, a default user is created
		with empty credentials
		which are, obviously, invalid
		and an empty notebook
	what should happen
		the last active user is retrieved from the registry
			default user assumed
		the user's database is loaded
			if no database is present
				create one
				with an empty default notebook
			if loading fails
				go to sign in with the error message
		the list of notes is retreived
			from the last active notebook
		the list of notes is displayed
NoteListView
	displays notes
		NoteListModel
	performs searches
		affects NoteListModel
		but indirectly
		since the search is within the current notebook
	lists notebooks
		UserModel
	displaying notes requires creation of HTML code and HTMLayout handling
		created from an internal format
		which should be as close to Evernote's as possible
		preferably, Evernote's format
			seems usable for internal representation
			better yet, create a note interface
			the real one will delegate to EN Note
				cache to allow access to members through interface
			the mock one will do something else
			nah, better convert on sync
		sounds like the problem in the paper
			they created an adapter that converted data
			but my problem is simpler
			merely one-way encoding
		streaming
			no need to encode all at once
			HTMLayout will need one DOM element at a time
				then, a mass update
	creation
		should be created before loading notes
			before the user is loaded
		so, the user should be loaded in responce to window being created
		create separate events for starting the UI and starting the model
			no, the app does not know when the window is created
			it should return to the message loop first
asynchronous start
	the model should not be loaded on the UI thread
	UI should be created first
		then the message loop should start running
		then the model should start loading on a separate thread
	everything is connected in advance
	so to start loading on another thread, a signal has to be made on another thread
asynchronous sync
	could be done using a worker thread
AppModel
	maybe, it is entirely redundant
	before the message loop starts
		everything needs to be connected
		and the main window needs to be created
	everything else should start in response to main window creation
		after the message loop starts running
	PostQuitMessage is a good way to terminate
lock hierarchy
	UI runs on its own thread
	UI also starts other threads
		loading data
		sync
	UI does not access other objects directly
		because it a view
	UI signals should not block
		because they return nothing
		however, they do signal user intent
		which might warrant some immediate UI changes
		so, it is not the view that decides on threading
	which non-UI operations should be serial?
		operations on any one model, obviously
		note list and a notebook could be modified simulatneously
			to search while syncing
			except for copying from the notebook to the note list
	solution
		model-wide locks
		only call getters while holding a lock
			everything that is called is called inside some lock
			so this condition makes no sense
		do not make signals from getters
		need another solution
database
	access should be encapsulated
		a separate class should return data from the database
			notes
			notebooks
			tags
			user data
		notebooks should not store notes
		but notes could still be accessed through notebooks
			notebooks could have references to the user model
			which would manage store and cache
		the alternative is to pass notebooks to user model
			which is awkward
	caching should be explicit
		caching policy should be flexible
		consumers should not know what is cached
	who should query the database
		UserModel should return ready-to-use data
		this data can come from cache or store
		UserModel has little other logic
		so let it do it
	editing
		edited notes have to be synced
			replaced with EN's versions
		editing needs to be fluid
			reloading note list bad option
		solution
			edit in-place
			signal editing complete
			notify UserModel
			mark the note for sync
			have UserModel signal note update
HTMLayout event handling
	alternatives
		process events within window
			- need a map indexed by two values
		create element behaviors
			- writing a class to foward a cilck
			- event switch
			+ easier attachment
HTMLayout resource loading
	by name
	maybe they could all be classified as HTML
sync with Evernote
	can implement sending by email at first
forward declarations
	should be made for interfaces in headers
		done
note access
	most data transformation should be done by data access layer
	data requests
		get a page of notes in a notebook
			filtered by keywords
			filtered by tags
			filtered by creation date
		get next page of notes
		get previous page of notes
		get a note
		get previous note
		get next note
	EN search grammar is non-recursive
	in the end, request becomes an SQL query
		same kind of filter can be combined
	solutions
		specialized functions, like GetNotesByNotebook
		generic function; client provides filters
			- verbose for simple queries
			- difficult to cache
data modification
	is database access is single-threaded?
		sync via separate connection
			can sync read/write data in one go?
			no, there can be long delays and conflicts
		wait, is it really single-threaded?
		loading notes might be time-consuming
		blocking UI for that period of time might be bad
			insead, disable some UI elements
			create a worker thread for creating the element HTML
			block UI to add one ready HTML at a time
			can be aborted
		so, data for HTML creation is loaded by a worker thread
			only one of these can exist at a time
		can other threads access the database?
			these threads would not be modifying or querying notes
			modify some other data?
				notebook name
		SQLite has three modes
			single-threaded: only one thread
			multi-threaded: one thread per connection
			serialized: multiple threads per connection
		target multi-threaded mode
	database access from sync thread and ui thread
	ui thread and ui data thread are different threads
		ui thread
			processes messages
			enqueues data tasks
		data thread
			executes data tasks
			sends messages to ui thread
	so, what happens when the user enters a new note title?
		ui thread asks data thread to make the modification
		data thead comits the modification transactionally
		data thread notifies ui thread of completion
		ui thread changes the note title
	GUI is only modified in response to window messages
	view classes can have setter methods
		if they do not modify GUI
			therefore, can be called from other threads
		also, if they do modify GUI
			these methods post window messages
	should there be different db models for sync and processing?
		no, they return the same data types
	should there be different db instances for sync and processing?
		each instance with its own connection
		each with its own caching, if needed
		seems like a good idea
	so, how should last used notebook be returned?
		stored as a name-value pair
		db passes a notebook object to the user model
		the user model passes it to the presenter
		the presenter processes it
		maybe creates some new object for a view
		the point is, db access is single-threaded
		so the database can return a pointer
			there is always at least one notebook
			there is always a default notebook
			the pointer should never be null
		if the pointer is never null, it can be a reference
		the class member can be a pointer
			assert not null before returning the reference
threading
	I don't want to implement threading right away
	but threading should be easy to add later on
	the threading model is dictated by sqlite and htmlayout
	each db instance represents a db connection
	access to each db instance is single-threaded
	all ui should be single-threaded
	we therefore have a ui thread and a thread per db instance
	ui thread
		signals from ui create data thread tasks
			presenters handles this
		ui getters send messages
			ui handles this
			sending on the same thread does not lock
			signal handlers from data threads should avoid getters
		ui setters post messages
			ui handles this
	data thread
		one per db instance
		should then be implemented in the db
		the db should have a message pump
	want to avoid bothering with messaging and tasks for now
database
	when should it be initialized?
		when it is being created
			check if the database is empty
			check for the properties table
		in future, when converting an old format
	how should it be initialized?
		assuming it is empty
		create tables
			properties
				version
				user name
				last used notebook
				default notebook
			notes
mobile testing
	need simple alternative to boost::test
	can copy stuff
	how can I implement AUTO_TEST_CASE?
		create a function taking a Test parameter
		add a pointer to the function to some global list
			how?
		create a base that adds itself to the global list on construction
		create test case classes that inherit from the base
		create a static instance of every such class
identity
	notebooks are identified by GUID
		but also have unique names
	unsynced notebooks have no GUID
	therefore, names are the real identifier
	what about notes?
	they don't have unique names
	when I want to open a note, a have to refer to it by some id
		by GUID
	therefore, notes need to have GUIDs
	maybe notebooks should have GUIDs too, then
	they can be assigned GUIDs automatically between syncs
	these would be replaced by server's GUIDs after sync
		views would have to be updated after sync completes
	also, the DOM elements need a GUID attribute
sync update
	GUIDs change after sync
		and possibly other fields
	if the note list is being displayed
		the query should be repeated
	if a note is being displayed
		it should be fetched from the database again
		deleted if absent
		but how, if it's GUID is old
		need a map from old GUIDs to new
	if a note is being edited
		TODO
mobile testing exceptions
	are often not caught
		fixed
	also need to test for exceptions
		done
mobile testing fixtures
	setting up the database every time is taking up space
	need two different classes
		global one to register the test
		local one to be created with a  fixture
UTF8 strings
	vector<unsigned char> is a bad container
	can't get a pointer when empty
	can add checks for empty vectors
data store initialization
	sqlite3_open_v2 creates a database that is either
		has no version
		has lesser version
		has greater version
		has correct version
	it is better not to try handling invalid databases
		what about db creation errors?
			up to ACID to handle
note import
	EnImporter needs to allocate notes
	no need to have them live outside OnImport handler
	options
		create EnImporter locally
			- can't use an interface, then
		have EnImporter use outside storage
			- different from DataStore
				maybe DataStore is the one that needs to change
				if it does not want notes to live between calls
		make EnImport clear its memory
			- extra call; might forget
SQLite wrapper
	need to destroy statements automatically
note list design
	need to set overflow for titles etc
		done
data interface revamp
	is there a need for INote, INotebook, ITimestamp, or ITag?
		they contain no complicated logic that might need to be mocked
		removing them would cut down the number of classes by 12
		what if I decided to add complicated logic later?
			like, connect them to the database
			seems like a bad idea even without the class overhead
	how should these objects be passed around?
		constraints
			avoid copies
				create a list of content
				pass it to the end consumer
				without caching
			single-threaded
			notes can be imported
			note info used for note list display
			note info can be edited
			note content displayed occasionally
			note content can be edited
			can filter by tags
			can rename notebooks
			can change default notebook
			can change last used notebook
		note list view does not have to store notes
			can store query
		currently
			query database
			cache the result in the note list model
			get results from this cache for the view
		alternatively
			store query in the note list model
			query database by note list model
			pass results directly to the view
		database queries can be stored by either value or pointer
			std::vector or boost::ptr_vector
			we no longer use interfaces for data
			so, no use for ptr_vector
		implementation
			database query functions return (const vector &)
			note list model returns (const vector &)
				where does it get it from?
				can either get it directly from user model
				or cache it
					can store the reference
						can't switch references
						store a pointer
					but then initialize it with an empty
					have to store the empty, as well, then
					good for resetting, actually
			presenters iterate through vectors
			view functions add entries one by one
	user model / data store split
		right now, they have almost identical interfaces
		a database is per-user
		user model controls database lifetime
		user model contains the database object
		separate user model would be used for sync
			with separate database connection 
			with read-write rights
			except, no use in creating a new database for sync
				so, different loading policies
		maybe data store should be a thinner sqlite3_db wrapper
			with a statement wrapper, as well
				RAII
				lazy parsing
		then user model should allocate a database and statements
			then call statements as needed
		thin database and statement wrappers are easier to test
			user model can then be properly tested on PC
			also avoiding untested private methods
database use testing
	mock database can't evaluate SQL
	might be better to just use the real database
	then I will need a real database whenever I involve UserModel
		for almost all tests, that is
	but, no; I can use MockUserModel instead
	test only UserModel itself with the mobile test suite
full-text search
	don't want to store raw note bodies in the FTS table
	because they contain tags and other stuff we don't want to search on
	even title, actually, might contain special markup
	should store originals in the note table
	should store stripped text in the FTS table
note view class design
	constraints
		modal
		create note view as child of note list view
		subscribe presenters to note view events
			presenter initialized after view
		might want to cache data for the view
			including window
		should not expose window-specific things in interface
menu bar handling
	constraints
		sends commands to a specific window
		is a top level window
		should have different buttons for different active windows
note resources
	requirements
		render pictures
		play audio
		attach files, audio, and pictures
		search images
	constraints
		identified in note contents by hash
		zero to many resources per note
		has MIME format
		has format-specific fields
		has recognition data
		has zero or more attributes
	choices
		one class with all necessary fields
		multiple classes
			common interface
			no common interface
	one class scenario is wasteful
	would also add unecessary logic
	multiple class scenario seems better
	no need for common interface
	there are few common operations with resources
exception testing
	requirements
		test that exception of the given type is thrown
		test a specified predicate on the exception
	plan
		take the statement
		give it catch of the specified type
			check the predicate there
		give it an ellipsis catch
			report an error
note resource handling
	requirements
		should be handled by NoteView
		others should be handled by HTMLayoutWindow
	HTMLayout gets requests through notification subscription
	can make the function virtual
	ask the descendant to call the base implementation
	there are several ways to fufill data requests
		send a signal with a blob reference
			- new type of signal required
			+ can protect against multiple providers
				by only letting one connect
		send a signal, provide blob setter
			- does not protect against multiple providers
			- non-local data storage
		a data loader object
			+ guarantees retrieval
			- introduces model dependcy
	special signal seems like the least of evils
	the lack of good choices is due to the immediacy of data loading
	the function has to return LOAD_OK right away
note resource storage
	requirements
		data should be available while it is loaded
		data for more than one note might be needed for one view
			for transitions
	data should be stored by the presenter
	does it?
	if it only needs to be available during loading, storage in view is enough
kinetic scrolling
	basic premise
		play scrolling animation
		mouse drag creates impulse
		friction reduces impulse
		animation stops when impulse vanishes
	animation
		similar to a game loop
		scroll continuously on idle
	state
		idle
			mouse down, move beyond threshold => dragging
		animating
			mouse down => dragging
			velocity drops below threshold => idle
		dragging
			mouse up => animating
				set velocity
		refactoring
			does it make sense to handle animation in another class?
				math
				state management
				make explicit data needed for state transitions
			interface
				SetStateAnimating
				SetStateDragging
				SetStateRefactoring
				GetState
				GetDistance(time)
			dragging and animation are fairly separate, though
			dragging is strongly tied to message processing
event subscription
	applications
		window subscrption to button clicks and selection changes
			call void() function in response to event
		kinetic scrolling animation
			scroll control in response to mouse events from it
		note flick animation
			repaint note view in response to mouse events from it
	requirements
		bind to specific elements
		bind by selector
		subscribe with the correct parameters
		subscribe member functions
	handler signatures my differ
	can create adapter functions
		that will convert parameters and call the given handler
		of a given object
	but the function pointer would require the subscriber's specific type
	how does boost::signal solve this problem?
		takes a slot_type reference
		slot_type is an object
	how does SWL handle this problem?
		creates a static proxy for each object type and message id
		supplies specialized message parameter object
	we have two scenarios
		one object handles behaviour events from multiple elements
		one object hnaldes miscellaneous events form one element
	it makes sense to keep the old system for the first scnenario
	subscribe event_handler obects for the second
	why oh why did I not stop at this point?
animation
	two message loop modes
		static
			GetMessage
			check for a "start animating" message
		animation
			PeekMessage
			repeatedly call animation functions while idle
	animation class
		provides
			flag for stopping animation
			step frame function that runs some animation
			methods to subscribe and unsubscribe animation functions
note preview
	want to display the thumbnails in note list
	have to insert the <img /> tag into the note html
	add a LoadingData handler to NotePresenter
	where to get the image data from?
		generate on the fly or pull from the database
		database storage can't be permanent
		because format may change
		although, this can also be made part of the data format
		except, we may decide to change format based on screen orientation
		even if it seems like a bad idea at the moment
	how to generate the data?
		HTMLayoutRender
			takes window handle, bitmap, and rectangle
			should use native format (16bpp)
		does it render to bitmap area or to window client area?
			client area
		how can I load HBITMAP data?
			could implement an event handler with on_draw
			seems like the way to do it
			also answers the question of whether caching is necessary
			if I draw, then it is
		so, the general idea is
			note list presenter
				clear title and subtitle
				set note body
				render to an HBITMAP array
				set the index as an attribute
			note list view
				subscribe to draw events from the newly added notes
				in handler, get the index attribute
				signal for HBITMAP with given index
				draw using the returned handle
		now both note and note list presenters are handling note list changes
		but if images are cached in the database
		then note list presenter will need to pull them
			to avoid making unnecessary queries
		actually, the note window would be creating the bitmap initially
			Render(HTBITMAP & bmp)
		then note list presenter needs access to note view
	implementation
		√ get HBITMAP drawing working
		add rendering
		add caching
	note view does not exist when notes are initially loaded
		on note list view creation
	note view is required for preview rendering
	therefore notes should be loaded after both views are created
	maybe main should initiate user loading manually
	image creation
		there seems to be no way of getting the bits
		CreateDIBSection hands out the pointer
		Imaging library can be used for processing
sync
	when sync connects to EN, the password might be rejected
	then sync brings up the signin window to get a new password
	two ways to proceed
		modal
			spin a new message loop in the signin window
			return control to sync when finished
		non-modal
			generate a request event and suspend sync
			generate a completion event and resume sync
	keep in mind that sync is in a separate thread
		any signals it sends are processed on its own thread
		sync has a separate user model with a separate db connection
		we don't want 2 UI threads
			so sync needs to display the dialog on the UI thread
		2 ways to run code on the UI thread
			window messaging
			main message loop augmentation
	general scenario
		sync does its own thing
		UI does its own thing
		sync gets in trouble, asks UI for some data, goes to sleep
		UI interacts with the user, gets sync its data, resumes it
	how to enable this
		the presenter would interact with sync's user data
			under assumption that sync is sleeping
		sync cannot signal an event directly
			has to leave some sort of message
	SyncModel
		presenters subscribe to events
			standard Connect methods
		sync calls method SetCredentials and blocks
		message pump calls Process, which signals events
		presenters modify sync's credentials model
		finishing the event unblocks sync
	lets look at it from another side
		sync starts with user credentials and runs until either
			it runs to completion
			the credentials are rejected
			some other error occurs
		sync starts when
			the sync button is pressed
			invalid user credentials are updated
		this no longer looks like a parallel thread
			rather like a worker thread
	SyncModel
		Sync method
			starts a new thread
			runs sync to one of the termination conditions
			if credentials are needed
				posts the appropriate message
					PostThreadMessage
				message loop asks it to dispatch the message
		DispatchMessage
			if sees the message sent by Sync
				raises the credentials.Updating event
				checks whether credentials were set
				restarts sync, if they were
	too much logic inside the model
	need to split this into a model and a controller
	SyncController
		initiates and controls sync
		displays credentials requests
	SyncPresenter
		runs the Sync method
		posts events to the window message queue
	instead of using Windows messaging, SyncModel can have its own
	much of the syncing code would be in EnService
	how much?
		download/upload notes, notebooks, resources
signin
	two sources
		sync needs new credentials
		anonymous user conversion
	what kind of presenters do they call for?
		UserSigninPresenter
			subscribes to NoteListView.SignIn
			updates current user's credentials
			converts the user to a named one
		SyncSigninPresenter
			subscribes to SyncModel.NeedCredentials
			updates the sync user's credentials
			restarts sync
		could sync and main user models end up with different credentials?
			do not cache them, but store in the database
	should signin update the user's credentials?
	after all, it is not his credentials that are set, but the next user's
	what to call these credentials?
		newCredentials
thumbnailer
	overview
		takes an HTMLayout window handle and a thumbnail size
		creates a window-sized DIB
		renders the window into the DIB
		creates an image object
		resizes it to thumbnail size
		creates a memory stream
		encodes the image as a jpg into it
	the imaging API is much too complex
	lets try using the graphin library
		jpg support not compiled
	JPEG options
		Imaging
			complicated
		libjpeg
			complicated
		graphin hack
			might be impossible
	went with the Imaging option — it works
	the note view shoud hide its UI when not shown
		TODO
	error handling needs testing
		TODO
thumbnail storage
	store the thumbnail with the other note data
	record the size, to update, if size requirements change
	retrieve the thumbnail with the note guid
	check the retrieved thumbnail size
	if different, replace the thumbnail
anonymous user
	now called [anonymous]
	disallow signing in with this username
		done
	add a test for this
		done
user management
	right now, the Evernote credentials are used for user's credentials
	what if I decide to add support for another note service, such as OneNote?
	then things become much more complciated, so lets not do that
	if I decide to switch from Evernote to OneNote, there would be no problem
	what about passwords?
	do I store the password for the last user only, or for all users?
	when a user signs in, he has to enter the password
	so there is no use in storing it
	what if the user logs out accidentally and has no access to network?
	he should be allowed to log back in
	so we don't check password on login
	however, sync needs the password
	it is better to get it from the database
sync
	must be capable of full sync and incremental sync
	full sync = clear clean records from db, then perform incremental sync
	implementation plan
		UI
			sync button
		user management
			last user
			credentials storage
		data model
			transactions
		threading model
			sync thread spawning
			sync result processing
				can skip the signin requesting for now
		download headers
			clear database
			authenticate
			getSyncChunc with afterUSN=0
			getNote
		full download
			download resources
		sync
			implement generic negotiation logic
			apply it to tags, notebooks, notes
credentials
	user credentials should be fetched from the database, not cached
		username and password in a single transaction
	new credentials should be cached
	there is no need to subscribe to user credentials updates
	so, we can create a POD credentials object
transactions
	which operations are performed with UserModel?
		EnImportPresenter::OnImport
			get last used notebook
			add a bunch of notes
			add a bunch of resources
			retrieve the notebook notes
		NoteListPresenter::OnLoadThumbnail
			get thumbnail
			set the thumbnail
		NoteListPresenter::OnUserLoaded
			get all notebooks
			get last used notebook
			retrieve the notebook notes
			get credentials
		NotePresenter::OnLoadingData
			get an image resource
		NotePresenter::OnOpenNote
			get a note body
			get a note
		SearchPresenter::ResetNotes
			get last used notebook
			retrieve the notebook notes
		SearchPresenter::SearchNotes
			get last used notebook
			retrieve the notebook notes
		UserLoader::Save
			get credentials
		UserSignInPresenter::OnCredentialsUpdated
			load
			set credentials
		UserSignInPresenter::OnSignIn
			get credentials
	transactions clearly have to be handled outside UserModel
		need to create RAII transaction objects
	imortantly, how to test transactions?
		have to create two UserModel instances
		the instances have to access the database concurrently
		on different threads
		have to make sure the database blocks properly
		one thread needs to
			enter a transaction
			make a write
			spin off another thread
		the second thread needs to
			enter a transaction
			try to make a write
		the first thread needs to
			make sure the second thread is blocked
EnService sync interface
	tasks
		download notebooks
		download notes
		download resources
	no, wait, server state is retrieved in chunks
	therefore we can't make separate requests like this
	tasks
		download state
		download resources
	both the client and the server can change during synchronization
	what we want to do is
		download the data at the moment of sync
		minus those pieces that are deleted during sync
empty notes
	occur during partial sync
	can either
		show them somehow specially
		not show
	the latter option is preferrable
		fewer user distractions
		less program logic
	better yet, don't commit empty notes
an unhandled exception is raised at startup
	the "Database could not be loaded." exception
	fixed
notes are not synced until I click anywhere
	because sync messages are only processed after windows messages
	if no windows message arrives, sync waits
	solutions
		send windows messages
		wake up the thread on sending
layout problem
	menu moves if I click before notes appear
	the body keeps its size
	the window keeps its size
	list view mouse handlers play no role
	the culprit is the hiding of the profile name
	how about we do not hide it?
	but instead set it to some neutral string
	after all, even the anonymous user might want to see some profile info
note images
	only the last image is displayed
	because of the way caching works
	cache all the images
	clear the cache when the page clears
	actually, this might not be the problem
	need to convert gif images to png
		no, the base64 decoder was incorrect
		need to add a test for trailing newline
		done
	now, there is an encoding problem
resource upload
	need to return several pieces of information for each
		data
		hash
		mime
	also, it would be better to copy to the final array right away
sync logic
	want a separate component
		that will make decisions to follow
	full sync
		logic
			if remote, not local
				add local
			if remote, local conflict
				if dirty
					merge
				else
					rename local
			if local, not remote
				if dirty
					upload
				else
					delete
			if remote and local
				if same USN and clean
					do nothing
				if same USN and dirty
					upload
				if remote USN higher and clean
					replace with remote
				if remote USN higher and dirty
					merge
		data
			remote: availability, GUID, USN
			local: availability, GUID, USN, dirty flag
		decisions
			add
			merge
			rename
			upload
			delete
			do nothing
	incremental sync
		logic
			if remote, not local
				add local
			if remote, local conflict
				if dirty
					merge
				else
					rename local
			if local and remote
				if dirty
					merge
				else
					replace with remote
	difference between full sync and incremental
		starting USN
		same USN handling
	EnService should contain as little logic as possible
		factor it out later
	SyncLogic usage
		build the remote resource list
		build the local resource list
		process remote-only, local-only, and conflicting
	resources to sync
		notes
		tags
		notebooks
	resource list building
		identity via guid
		build full local and remote lists
		build a guid set for each of the lists
		traverse each list
			checking the guid sets
			calling the appropriate sync function
	data types
		locally, we have Note, Notebook, and Tag classes
		each has a GetGuid method
		EnService could return same classes
		the classes then also need to have GetUsn and IsDirty methods
	need to know which notebook to upload a note to
		should sync by notebook
		then I can set the notebook for the whole NoteProcessor
	this ad-hoc "getting it to run" approach results is messy
		suspect much wasted effort
	need to refactor EnService
		should provide only basic services
			login requires credential verification
			SyncModel needs to fetch remote resource lists
			SyncLogic performs the following operations
				Add(remote)
				Delete(local)
				Rename(local)
				Upload(local)
				Merge(local, remote)
			note addition entails resource download
			uploading entails local note replacement
		this requires the following 
			CheckCredentials
			ListEntities
			DownloadNoteResources
			UploadNote
			UploadNotebook
			UploadTag
		many of these operations are interdependent
			sync resources determine what gets downloaded and uploaded
			need to upload and download notebooks and tags before notes
		there should be a minimum of logic in EnService
		it should be a dumb adapter between app logic and EN API
			it should handle EN exceptions
		EN works by sessions, therefore EnService has to expose sessions
			can expose user store and note store sessions
	sketch
		EnService
			GetUserStore
			GetNoteStore
			UserStore
				GetAuthenticationToken
			NoteStore
				ListEntities
				DownloadNoteResources
				UploadNote
				UploadNotebook
				UploadTag
	exceptions
		maybe EnService should catch exceptions and return error codes
		to avoid building CheckCredentials logic on exceptions
		if the stores are RAII objects, then they cannot be returned
		overall, connection problems are entirely expected
		adding an error handler for broken connection is another alternative
		we don't want to keep working with a store, if the connection is lost
		so, throw on connection lost
		GetAuthenticationToken should return an error message
	sync sequence
		tags and notebooks are independent
		they get synced first
		we only want to sync notes in the current notebook
		however, the current notebook might not exist on the server
		it might even get deleted
			ohi, sync dis notebook plz
			nowai! i deletd it
		in such a case, deleting the notebook is all that's needed
		if the notebook did not exist and was uploaded, populate it
		in either case, the remote note list will be empty
		how do I find out that the current notebook was deleted?
			in such a case, lastusednotebook should return the default
		do I need to find this out?
			if  the notebook is deleted, the remote note list is empty
			the local note list is also empty
			syncing is then a NOP
			as long as I get the current notebook before deleting it
	note resources
		once a decision to add a note is made, its data needs fetching
		getNoteContent requires note Guid — easy
		getResource requires data Guid
			these are not stored in our Note classes
			this is the only place in which they are needed
			so, it does not make sense to add them to the Note class
			could add a class to package note with resources
			peform sync logic on that
			what to call it?
				NoteWithResources
				EnNote
				TransferNote
				NotePackage
			something to say that it includes everything for EN interop
				EnInteropNote
		upload requires several pieces of information
			data
			guid
			mime format
			hash
		need more sophisticated resource objects
			blobs not sufficient
		this could be useful in other places, too
		these would be large imuutable objects
			do they really have to be immutable?
			what if I want to dither a bitmap before rendering it?
			I am not sharing it with anyone, if I hold the memory
		need to return them via shared pointers or pointer arrays
			is there another way?
			want to avoid reference counting and memory allocations
immutable class storage
	returning an immutable class copies it
	an immutable parameter cannot be initialized via reference
		because it is constracted before function call
	this means that these can only be returned by reference
	would like to have a class that is mutable until fully constructed
errors
	smileys do not show up
	thumbnails do not scale
	an unnamed database is created
	cause: freak VS error
	cause:
		restarting the device emulator with old code
		not selecting client for deployment
		running client
testing
	need to update tests for update processor upload functions
	replacements need testing
	can't test NoteProcessor, since it talks to the server
notebook deletion
	deletion of the default notebook should not be possible
		throw on attempt
		the alternative would be to just delete all notes
		but this is not a necessary user story, for now
	deletion of the last used notebook should reset it to default
		handle this in the user model itself
	add tests
		done
sync logging
	need to record data going in and the operations performed on it
	it should be possible to disable it
	keep in mind that other parts of the application may also need logging
	I want to view information in a file
		this file can either have sync-specific format
			or a neutral format
			or a mix of formats
	say, I am logging performance data, as well as sync
		I don't want them to mix
		therefore they can't be writing to the same stream
	if they have different streams, do they have anything in common at all?
	if not, instantiate a bunch of logger objects in main
		pass them to appropriate classes by reference
	the objects could be initialized in main
		then adjusted at runtime
	seems like a flexible approach
	how do I display item actions?
		items need to be identified somehow
		GUID is not a convenient identifier
		but it is the only one that is unique
		therefore we'll use it
		no use in shortening it
		can always scan by the first characters visually
need to refactor SyncModel
	the SyncContext looks like a really bad idea
	it duplicates most SyncModel members
sync troubles
	have a remote notebook and a local notebook
	same name, different Guids
	the algorithm downloads the remote and uploads the local
	yet, names have to be unique
	same thing with tags
	the algorithm has no provision for this
	fixed
database constraints
	notebook deletion should cascade to notes
	note deletion should cascade to resources and FT3 data
	tag names should be unique
	notebook names should be unique
	adding a note, noteboo, or tag should replace the one with the same key
		do INSERT OR REPLACE
sync ui
	which presenter should be responsible for updating the sync indicator?
	which ones shows it in the first place?
		NoteListPresenter
			OnUserLoaded
	same entity should keep track of its contents
	the dirty note count is a property of the notebook
		what about dirty notebook count?
		what about dirty tag count?
		they should be added together
	the total dirty count is a combined measurement
notebook selection event
	notebook list is modified dynamically
		during loading and during sync
	ConnectBehavior might be called any time after loading
		this seems to be consistent with current implementation
	however, ConnectBehavior takes a path
		I have a handle, instead
	there might be a need for a NotebookListModel
		SyncPresenter would update it
			on the UI thread
		NoteListPresenter would react to the updates
			by updating the menu and the behaviour connections
	notebook removal invalidates behavior connection records
		need DisconnectBehavior
		can work similarly to ConnectBehavior
item change events
	item processors need to be able to enqueue messages
	they can't use SyncContext directly
		because it is a private nested class
	maybe this is the time to reform SyncModel
	it only needs to synchronize some actions
		EnqueueMessage
			ProcessMessages
		GetStopRequested
			StopSync
	could make the message queue a separate class
		then the processors will be able to use it
		then its locking would be transparent
			and the context only needed for the stop flag
delayed sync logic
	there are a few problems with the current approach
		operations might have to be reordered
		ui needs to be updated with progress
		the actions might need to be halted midway
	all of these things would be easy, if action processing was delayed
	then there would be no need for processors
	SyncLogic would generate a list of actions, instead
	but this should be done after the sync indicator is up
		TODO
updating dirty note list on note edit
	there is currently no signal for committing note edits
	this should be a note list model signal
	how would it be triggered?
		importing notes
			trigger after updating the note list
		note edit
			trigger after updating the note
			acts on the note, not the list
			is it possible for the note to not belong to the list?
				the note would be selected from the list
					could be false for linked notes
					depends on linked note implementation
					not immediately relevant
				the list can't change during editing
				therefore the note has to belong to the list
		could set a flag, instead of signal
	could instead make it a UserModel signal
		then there would be no possible problems with linked notes
		the signal could be triggered automatically
			on note add
			on note update
		the notes are not the only thing that may become dirty
		therefore, the signal has to be triggered by the database
			when anything dirty is added
			except that changing dirty to clean is also significant
			when anything is added
		it does not make sense to send the signal from inside a transaction
		need to set a flag, signal at transaction end
		the database can be modified from multiple threads
		therefore, can't rely on SQLite to signal changes
		signalling from UserModel won't prevent reliance on SyncModel signals
			because the signals need to be sent through the UI thread
	what if I trigger the signal through EnImportPresenter?
		presenters can't expose events themselves
		therefore, it would trigger the event on something else
			user model
				should not be done without automating, I guess
			note list model
				lets do that
		then it should be a flag, not a signal
			a flag visible to SignalChanged subscribers
			reset after the signal is fired
	this is all stupid
	I only need to update the sync counter on note list update
		that's all
	no special signal is needed
	why didn't I recognize this immediately?
		thought I need to know whenever a resource was changed
		in actuality, the event of the note list changing was needed
		_note list_ presenter should not deal with resource events
			did not think of that
SyncModel refactor
	need to delay action processing
	SyncLogic should generate an array of actions
	SyncModel should process the actions once they are generated
	the processing might involve reordering
	actions would be little structs
		all the same type
			enum type
			T * local (nullable)
			T * remote (nullable)
checkbox support
	general idea
		keep a list of the checkboxes
		when the note is opened
			record the initial state
		when the note is closed
			compare state with the initial
		if the checkboxes have been changed
			update the note body
			store it in the database
			mark the note as dirty
			update the note list
	parsing
		can either parse the notes twice or keep track of offsets
	can this be somehow generalized to regular note editing?
		checkboxes would have to be active then, also
		generally
			we would be editing HTML DOM
			then serializing it into EN's format
		we might still want to keep a list of checkboxes
			to recognize changes
			the alternative is to subscribe to events
				would enable immediate visual feedback
				we might want to let the user know the note is dirty
		editing requires complete note information in DOM
	hold that thought
	checkbox is special
		it does not clearly imply editing
		the user would not expect any other changes to result
	it seems, checkboxes should not be implemented as general editing
	back to the conservative approach
		keep a copy of the original note body
		record offsets to checkboxes
		record checkbox states
		on exit, check states, option
	implementation
		notes are processed by EnNoteTranslator
		can RapidXML return element positions?
			possibly, with non-destructive parsing
			then attribute value offset can be used
			however, entities will not be translated
				conversion is to HTML
				entity translation unnecessary
		this cannot be used during transformation, though
			transformation implies destructive parsing
			does it?
			not necessarily
			need to check
				no it does not
		record checkbox info during transformation
			how to retrieve it
				have value location, size, and content
				need to convert location into offset
					need main string location
			how to represent it
				need to store
					state
					value location
					value size
				add a POD class for this
					used during translation
					output from EnNoteTranslator
					stored by the note
						view, presenter, or model?
					global class
			how to store it
				transformation function has fixed signature
				therefore need to store it as class member
				can also store the main string location there
		new state retrieval
			the note view gets a slab of HTML
				no DOM elements to subscribe
			can find them via a selector
	problem: "checked" attribute is optional
		should replace the whole element
		RapidXml only stores name and value offsets
		could search for opening and closing brackets from name
		unless the tag has a separate closing tag part
		in which case proper XML parsing is required
	general editing is the only viable way to go
	implementation
		encoding
			have EnNoteTranslator save as much information as possible
		reset
		decoding
			new functionality for EnNoteTranslator
		dirty tracking
			"reset" reloads the note, makes it not dirty
			subscribe to checkbox behaviors
				mark note dirty on change
merging
	changing a notebook's guid requires an update operation, not delete/add
	otherwise, the notes in it will be deleted
sqlite init
	might want to call these explicitly
		sqlite3_initialize()
		sqlite3_shutdown()
	TODO
update processor tests
	testing is difficult now
		mixed with threading
		opaque
	fixed
note editor
	commands
		cancel
		checkbox
		ul
		ol
		bold
		increase indent
		decrease indent
		italic
exception handling
	exceptions should be raised by models and views
	presenters should be durable against exceptions
	presenters should keep logs
note update -> thumbnail update
	need to trigger NoteListView::SignalLoadThumbnail
	occurs at OnLoadData
	when the note is updated, the note list thumbnail should be refreshed
	"update" and "refresh" do not reload images
	need a special method calling HTLayoutDataReadyAsync
full test search
	should remove stopwords from the database
		TODO
	have to keep referential validity of the FTS table manually
	therefore, can't do INSERT OR REPLACE
		need to do SELECT, then INSERT/UPDATE
note merging
	simplest approach
		replace local with remote
			won't replace resources or tags
		better approach
			delete local
				resources should be deleted automatically
			add remote
				and the resources
"north east registry" image is not loading
	fixed
elastic scrolling
	goal
		list can scroll past the limits
		in that case, it should be attracted back
	physics
		dragging the list gives it a speed
		there is acceleration due to friction against direction of movement
		past an edge there should be acceleration towards the edge
	discontinuity
		can determine which edge the movement occurs towards
		calculate time to reach the edge
		calculate velocity at the edge
		if velocity crossed zero
			calculate position using the pre-edge acceleration
		else
			calculate position using post-edge acceleration
		friction changes direction
			when velocity changes direction
			this happens past the edge
	actually, there is very little need for any of this
tags
	rarely needed
	should not be part of the note structure
	should be retrieved like resources
	tags are different from resources
	in that a tag can be associated with 0-many notes
	how to associate notes with tags, then?
		NoteStore can retrieve tag names for a notebook
		user model should associate by name, too, then
			AddTagToNote(tagName, noteGuid);
input panel
	API
		SHHandleWMActivate
			keeps the panel consistent between activations
		SHFullScreen
			determines which elements to show
		SHACTIVATEINFO
			used only by SHHandleWMActivate
signing out is broken
	closed the database during a transaction
note replacement problem
	if the server replaces a note with one with the same name
		then it is duplicated on the client
	not the desired behaviour
	if the server deletes a tag, then creates another of the same name
		then such behaviour is desired
		wait, no
		we want to delete the old flag on the client, also
	what does the documentation have to say about that?
		if a tag withe the same name, but different GUID exists
		if the existing tag has no "dirty" flag
		rename the existing client tag
notebook list is not updated after sync
	the update did not fit into one 20-element chank
	implement a proper chunk retrieval loop
incremental sync
	some differences
		starts from USN greater than 0
		fullSyncOnly == false
			chunks contain expunged objects and resources
		assumes new resources have greater USNs
		does not delete local resources absent in remote
	implementation differences
		start from a non-zero USN
		specify fullSyncOnly == false
		list resources
		list expunged notes, notebooks, and tags
		update resources
		remove expunbed notes, notebooks, tags
	affected code
		new NoteStore.ListEntries function
			calling getNextChunk differently
			listing additional stuff
		Sync needs to be split up into full and incremental parts
		database needs to store last sync USN and time
		noteStore needs to fetch fullSyncBefore and updateCount
	updateCount
		if we sync by notebook
			we have to store updateCount by noteBook
			except, notes are not the only synced entity
			there are other things, like notebook deletions
				we don't want to double-sync them
			but note events want to be per-notebook
			can keep both global and per-notebook USN counters
			notebook USN ≤ global USN
			could sync using notebook USN
				sync notes with USN > notebook USN
				but filter out global events with USN ≤ global USN
			would this cause double-sync problems?
				global USN always gets reset
				therefore, no global double-sync
				a note can only belong to one notebook
				a notebook's USN gets reset when it is synced
				therefore, no note double-sync
			any other problems?
				a note belongs to exactly one notebook
				therefore, no missed notebooks
				global resources are updated normally
				therefore, no missed global resources
				do global resources depend on notes?
					tags      - no
					notebooks - no
					searches  - no
					resources - yes
				a resource belongs to at most one note
				therefore, resources should be synced per-notebook
				do global resources depend on resources?
					tags      - no
					notebooks - no
					searches  - no
				no other problems, then
			expunged resources do not come with USNs
				can't filter out glogal resources
				might double-delete global resources then
				is this a problem?
				could be, if they can be restored
					can't be
					API ref says expunging is permanent
				does not seem like a problem
		what about sync time?
			required to decide when to peform full sync
		delete vs expunge
			deleted notes can be restored
			deleted notes have USNs
			can I add deleted notes to the expunged notes list?
				to simplify processing
			either way, we remove the note
				and all of its resources?
		deletion
			incremental sync sees deleted notes that were never added
				if the note was added and removed before last sync
			could attempt to delete them, just handle the exceptions
	notebook note filter
		should be at ListEntries level
			for pulling changed
			if it does not exist on the server
				there will be no notes to pull
		should be at ProcessNotes level
			for pushing changes
			if it does not exist on the server
				it should be using updated data
performance profiling
	requirements
		always on
		little overhead
		easy to maintain
	targets
		animation frame rate
			for various animations
		loading time
	implementation
		no string map
			premature pessimization
		animation
			FPS = # of frames / seconds it takes to complete animation
				record when an animation starts
				count the frames in the animation
				add a performance event when the animation ends
			how to store this additional data?
				currently done with a signal
				would need to keep additional state with each connection
				does the signal library allow this?
					no
			if I don't use signals, what should I have?
				connection creates a record with
					id
					active flag
					the function to call
					the object to call the function on
					animation start
					frame counter
				connection returns an object for severing it
					severing means removing the record
					can't do it by index or pointer
						because these get invalidated by other removals
					type needs to be known to animation provider
						entails type of list it is handling
						entails type of record
				animation id
					could be supplied by animation source
						assuming one animation of a kind plays at a time
					knowing what ids there are, can preallocate the records
						add a flag to mark active ones
						does not seem like a good idea, though
					does not seem like a clean solution
						it leads to a clean solution, though
				what's in a clean solution?
					animation provider deals with the animator interface
					provider given a connection object
						without revealing animator implementation
				solution
					give the connection object
						connection id
						animator interface reference
		collection
			every time an animation finishes
				record the frame rate for its type
			this means I need to know the type of animation
			also need a place to record the frame rate
			MVP implementation
				create a profile model and a profile presenter
				the presenter would subscribe to various sources of profiling info
					and record them to the profile model
				the presenter might react to to changes in the model
					and update some special debugging view
				report presenter, or whatever, might also hook up to the profile model
			animation signal
				is it, really, appropriate?
				would require methods like
					ConnectAnimationCompleted
					GetLastAnimationId
					GetLastAnimationFps
	display
		show in status bar
note editing
	switch modes between editing and viewing
		no, only go from viewing to editing
		lets us use a separate editing window
	layout
		toolbar
		title
		tags
		editing surface
		ok-sip-cancel
	separate window
		separate MVP
note state for editing
	problem
		windows contain only partial note state
	current solution
		store remaining state in the presenter
	make sense, because view does not need the full state to function
	also, note body is not part of the Note structure
	except
		note is associated with exact combination of views and editors
		event though it is specific to the view alone
	if a note is to store complete note information
		it would have the logic for saving state to it
		this logic probably should not be in the presenter, anyway
		since it does not reflect user stories
		lets try it
	note translation
		should not be performed by the view
		the view should get translated bodies
		what about the subtitle?
		it contains a formatted tag list
	the view should take a Note in additiona to all the other data
		not instead
editor implementation plan
	√ implement proper state saving
		for editor, not viewer
	√ test current implementation
		creation
		editing
	update tests
	standard formatting commands
	checkbox insertion
	presentation
		command buttons
probably should rename view.hide to view.close, where appropriate
	TODO
losing formatting
	open opening a created note
		could be during opening or saving
	TODO
should factor out URI loading
	kinds of URIs
		relative
			no colon
		thumbnails
			thumb:
		note images
			img:hash.ext
	what to do with asynchronous thumbnail updates?
		use the loader
	thumbnail updates
		when the thumbnail is absent or has wrong size
			it is created and stored in the database
		this requires the note guid
			embedded in the url
	problem
		thumbnail creation requires NoteView
		NoteView requires html data loading
		we have a recursive relationship
	one solution is to
		set the link
			after iniitializing the views
			but before showing them
		would change the reference to a pointer
	another solution is to
		not generate thumbnails lazily
		generate them on note creation and editing instead
	yet another solution is to
		hook up html data to views loading via a presenter
		as a bonus, the views won't all have to change constructors
		however, HTMLayout subclassing in an implementation detail
		it would not be visible to a presenter
		URL loading should not be exposed in the interface
		however, the presenter could take HTMLayoutWidow references
note resourses are not uploaded
	after importing a second smiley note
		the sync action is Add, not Upload
	EnInteropNote lacks resources
		they are not handled at all in SyncModel::GetNotes
	fixed
notes are uploaded to the wrong notebook
	should set default notebook prior to upload
	should be set in set in Note.notebookGuid
	fixed
updating note title fails
	ENML validation
	double <en-note>
	fixed
Thrift malfunctions
	getting a 1 GB message
	actually a 405 error: GET not supported
	strange, because I use POST
	was using wrong URLs
checkbox graphics are not loading
	should have returned LOAD_OK for unknown resources
		not LOAD_DISCARD
selection in edit view is not visible
	HTMLayout bug
	fixed
notes do not pass ENML
	needed to specify ENML2.dtd
updated note is uploaded as a second note
	API has separate function for updating
	might want to create a separate action for updating
	can't tell whether a note already exists on the server
		for incremental updates
	need to mark unsynced notes
		by assigning special GUIDs
		prefixing or postfexing a special character
		postfixing is cheaper
			it is the more common operation
sync testing leaves much to be desired
	updating, logging
	TODO
can't open updated note
	even after restarting
	preview does not update
	crashes on exit
	crashes even on download
	crashes on opening synced notes
	ReplaceTodo had a bug when
		a todo div was present without a "checked" attribute
paging
	can implement either in view or in model
	NoteListModel can limit itself to accepting only a set number of notes
	after that, display paging controls
	paging controls fetch more data into NoteListModel
	how to implement paging
		some people have thousands of notes
		would it be acceptable to load metadata for all of them?
		each note contains
			guid:         64
			creationDate: 8
			name:         200
			usn:          4
			isDirty:      1
		total size: ~300
		1000 notes => 300 KB
		not too much, actually
		if memory consumption becomes a problem => use smaller notebooks
NoteListView::AddNote passes strings by value
	also AddNotebook
	fixed
scrollbar does not appear after signing in
	because all 4 notes fit
	and pagination controls are not being set
	NoteListView::UpdateNotes is called from only a single place
	NoteListView::UpdateScrollbar has zero contentSize
	could be because the window is hidden then
		or disabled
	indeed
notes are not sorted by date
	actually, sorted in ascending order
	should be in descending
new note is created with zero creationDate
	fixed
checkboxes don't work
	get drawn correctly
		in the viewer
		in the editor
	xcall asserts
the list of notes should not be a list of options
	should be a list of buttons
thumbnails are not updated after checkboxes are edited
	throws an exception
		trying to load thumbnail from resources
		fixed, but not the cause
	thumbnails are updated and saved to the database
	but not reloaded
	picture does not update, unlike img
crashes on exit after creating and updating a note with 4 checkboxes
	and after simply restarting
	coming out of HTMLayoutProcND
		WM_DESTROY
			turns off window handlers
		maybe the stack is corrupted
			it is
		how to find the actual caller?
			has to occur in either
				message handler
				destructor
					at the end of main
					does not get there
				SendMessage from the same thread
		need to change strategy
			try to reveal the bug in another place
			it happens even with an empty notebook
			r4 = 0x01a86480
	the checkbox was created with the wrong xcall
selected note can't be selected again
	changed the list to a series of clickable panels
threw an unhandled exception on attempt to commit an edited note
	edited checkboxes in the viewer, then opened the editor
	the viewer was setting checked=""
signin screen should accept "enter" in the password field
	TODO
note editor checkbox changes are not persisted
	c-smile said he'd fix this
	TODO
links should open in a browser
	TODO
sync counter is not updated after a note is edited
	reloading the list fixes this
internet address could not be resolved
	no error message is displayed
	no internet connection
sync with DonReba did not upload my notes
	probably because my notebook has the same name as the default
	update count issue?
	incremental update is done starting at notebook update count
	the fundamental issue is that notebooks have two update counts
		last note update count
			use this to decide, whether to sync notes
		notebook update count
			use this to sync notebooks
	does it make any sense?
		at sync need to get changes to notes and notebook info
		notebook USN is never smaller than the note list USN max
			because notes can be ignored, but not notebooks
		at sync we retreive changes starting with the note list USN max
		syncing different notebooks could retrieve changes from intersecting time periods
		should ignore non-note changes below global sync date
	note list USN max
		could be stored in the notebook or calculated
			calculating would loop through maybe a thousand elements...
			should not take long
			storing it would introduce an FD
				complicating logic
	note list update count is not the USN max
		it is the update count at the last sync
	implementation
		looks like the solution is
			to make notebookUpdateCount the note list max
			instead of the notebook usn
don't need to list notes for local notebooks
	currently, only the Guid is available
		should be enough
	TODO
screenshot notes
	should use distinctive notes
	lets look EN's screenshots
		mostly untitled notes
		many pictures
	only need five notes or so
		√ city place photo
		√ TODO list
		√ web clip
		√ product photo
		food photo
		nature photo
sync button is not reenabled on failure
	signing out, then back in crashes the app
		last used notebook was not set
			should this even lead to an exception?
			there has to be another notebook
				or if there is not
				could create one
		should add a test for this
			TODO

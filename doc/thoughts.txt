functionality needed
	fast loading time
	low memory footprint
	offline notes
	compressed audio
	checkboxes
	folder tracking
	snapshot sizing
	search
		EN has its own search facility
			only available online
		specifications are available
			so it could be implemented offline also
		sorting
original main screen buttons
	text note
	ink note
	snapshot
	audio note
	upload file
tech needed
	UI
		HTMLayout
	DTD checking
		only needed for testing
	THTTP
	ENML XML->HTML convertion
		TinyXML
		pugixml
		RapidXML
need to figure out the overall design
	highest level features
		view notes
			subsets of notes
			with sorting
		create notes
			text at first
			photo, ink, audio, files later
		modify todo notes
			by checking/unchecking
		find notes
		switch notebooks
		sync
	required functionality
		UI to view a set of notes
		UI to view a note
		UI to choose a method of note creation
		note creation UI
		note storage and retrieval
		note synchronization
	runtime design
		load main UI first
		delay-load the remaining functionality
		nah, not until profiling shows it to be a bottleneck
	UI design
		log in
			get username and password
			go to the main screen
			action
				OK/Cancel
		main screen
			create notes
			action
				Notes
			menu
				About
				Logout
				Exit
		notes view
			shows most recent notes
			options
				search
				sort
					HTMLayoutSortElements
				reset
			actions
				New note/Sync
		sync
			collapsible
			list sync events
				status
				progress
		soft keys
			neither the main screen nor notes view have main actions
			I could make a single screen
				with the following elements
					notes list
					new note popout
					synchronization indicator
					search box
					sort popout
			however, showing the new note screen is much faster
				more optimized for starting quickly
				less optimized for coninuous use
			how to place the elements
				search box at the top
				notes list has to take as much space as possible
				have to be on the bottom
				as buttons with text, like EN iPhone
					Create Note
					Sort by <order>
					Sync
				bad idea
				make Sync the default action
				make note creation a fake first note
				make sort/filter menu options
		new screens
			sign in
				username/password and link to evernote.com
				soft keys
					Sign in
					Cancel
			notes list
				notes list, search, creation
				soft keys
					Sync
					Menu
						Sign out
						Notebook
						About
						Exit
			note view
				note contents, prev/next navigation
				soft keys
					Notes
			note creation
				soft keys
					OK
					Cancel
			about
				branding, version, author, date
				soft keys
					OK
	data storage design
		store notes and settings
		EN has a flat data model
		so, we can make tables directly from structs
		unsynced notes
			should be stored with the rest
			but marked as asynced
		at sync
			query the database for unsynced notes
			replace them with synced ones received from the server
		full-text search
			provided by the FTS3 extension of SQLite
			used by the Windows EN client
	synchronization design
		sync is comprised of several tasks
			download new server notes
				getSyncState/getSyncChunk/getNoteContent/getResourceData
				resolve conflicts
			upload new local notes
				the server provides replacements for the local notes
				resolve conflicts
		sync connections
			USB always
			9G never
			WiFi probably
		manual sync
			needed for searching server notes
			uploading local notes
			either way, it is only needed in the notes screen
		fault tolerance
			downloading notes
				via SQLite transactions
			uploading notes
				create a log before uploading
				clear it on success
				try to repeat on failure
		need to show the user when sync is required
			how many unsynced messages he has
			this calls for a button, instead of the soft key
				not really
				could add a number to the soft key title
	program structure
		MVP - Presenter First
			DB and registry are the model
			the windows are the views with controllers attached
		main window is not always needed
			not when there is no user signed in
		who desides which windows are created when?
			some sort of overlord state machine
			created at startup
			decides which windows to show
			receives messages from these windows
			changes window states
		there should be a flat stateless core
			with heavy-duty functions called by the controllers
	user credentials
		CryptProtectData/CryptUnprotectData
	EN connection
		through credentials verification
			get AuthenticationToken from EN
		through note sync
			upload/download notes and resources
program start
	sounds like an event
	when the program starts with a user, his notes are displayed
		and his credentials not authenticated
		meaning, that valid credentials are not needed
		the user is, then, separate from credentials
	there should be a user model, then, with credentials and notebooks
	when the program starts without a user, a default user is created
		with empty credentials
		which are, obviously, invalid
		and an empty notebook
	what should happen
		the last active user is retrieved from the registry
			default user assumed
		the user's database is loaded
			if no database is present
				create one
				with an empty default notebook
			if loading fails
				go to sign in with the error message
		the list of notes is retreived
			from the last active notebook
		the list of notes is displayed
NoteListView
	displays notes
		NoteListModel
	performs searches
		affects NoteListModel
		but indirectly
		since the search is within the current notebook
	lists notebooks
		UserModel
	displaying notes requires creation of HTML code and HTMLayout handling
		created from an internal format
		which should be as close to Evernote's as possible
		preferably, Evernote's format
			seems usable for internal representation
			better yet, create a note interface
			the real one will delegate to EN Note
				cache to allow access to members through interface
			the mock one will do something else
			nah, better convert on sync
		sounds like the problem in the paper
			they created an adapter that converted data
			but my problem is simpler
			merely one-way encoding
		streaming
			no need to encode all at once
			HTMLayout will need one DOM element at a time
				then, a mass update
	creation
		should be created before loading notes
			before the user is loaded
		so, the user should be loaded in responce to window being created
		create separate events for starting the UI and starting the model
			no, the app does not know when the window is created
			it should return to the message loop first
asynchronous start
	the model should not be loaded on the UI thread
	UI should be created first
		then the message loop should start running
		then the model should start loading on a separate thread
	everything is connected in advance
	so to start loading on another thread, a signal has to be made on another thread
asynchronous sync
	could be done using a worker thread
AppModel
	maybe, it is entirely redundant
	before the message loop starts
		everything needs to be connected
		and the main window needs to be created
	everything else should start in response to main window creation
		after the message loop starts running
	PostQuitMessage is a good way to terminate
lock hierarchy
	UI runs on its own thread
	UI also starts other threads
		loading data
		sync
	UI does not access other objects directly
		because it a view
	UI signals should not block
		because they return nothing
		however, they do signal user intent
		which might warrant some immediate UI changes
		so, it is not the view that decides on threading
	which non-UI operations should be serial?
		operations on any one model, obviously
		note list and a notebook could be modified simulatneously
			to search while syncing
			except for copying from the notebook to the note list
	solution
		model-wide locks
		only call getters while holding a lock
			everything that is called is called inside some lock
			so this condition makes no sense
		do not make signals from getters
		need another solution
database
	access should be encapsulated
		a separate class should return data from the database
			notes
			notebooks
			tags
			user data
		notebooks should not store notes
		but notes could still be accessed through notebooks
			notebooks could have references to the user model
			which would manage store and cache
		the alternative is to pass notebooks to user model
			which is awkward
	caching should be explicit
		caching policy should be flexible
		consumers should not know what is cached
	who should query the database
		UserModel should return ready-to-use data
		this data can come from cache or store
		UserModel has little other logic
		so let it do it
	editing
		edited notes have to be synced
			replaced with EN's versions
		editing needs to be fluid
			reloading note list bad option
		solution
			edit in-place
			signal editing complete
			notify UserModel
			mark the note for sync
			have UserModel signal note update
HTMLayout event handling
	alternatives
		process events within window
			- need a map indexed by two values
		create element behaviors
			- writing a class to foward a cilck
			- event switch
			+ easier attachment
HTMLayout resource loading
	by name
	maybe they could all be classified as HTML
sync with Evernote
	can implement sending by email at first
forward declarations
	should be made for interfaces in headers
		done
note access
	most data transformation should be done by data access layer
	data requests
		get a page of notes in a notebook
			filtered by keywords
			filtered by tags
			filtered by creation date
		get next page of notes
		get previous page of notes
		get a note
		get previous note
		get next note
	EN search grammar is non-recursive
	in the end, request becomes an SQL query
		same kind of filter can be combined
	solutions
		specialized functions, like GetNotesByNotebook
		generic function; client provides filters
			- verbose for simple queries
			- difficult to cache
data modification
	is database access is single-threaded?
		sync via separate connection
			can sync read/write data in one go?
			no, there can be long delays and conflicts
		wait, is it really single-threaded?
		loading notes might be time-consuming
		blocking UI for that period of time might be bad
			insead, disable some UI elements
			create a worker thread for creating the element HTML
			block UI to add one ready HTML at a time
			can be aborted
		so, data for HTML creation is loaded by a worker thread
			only one of these can exist at a time
		can other threads access the database?
			these threads would not be modifying or querying notes
			modify some other data?
				notebook name
		SQLite has three modes
			single-threaded: only one thread
			multi-threaded: one thread per connection
			serialized: multiple threads per connection
		target multi-threaded mode
	database access from sync thread and ui thread
	ui thread and ui data thread are different threads
		ui thread
			processes messages
			enqueues data tasks
		data thread
			executes data tasks
			sends messages to ui thread
	so, what happens when the user enters a new note title?
		ui thread asks data thread to make the modification
		data thead comits the modification transactionally
		data thread notifies ui thread of completion
		ui thread changes the note title
	GUI is only modified in response to window messages
	view classes can have setter methods
		if they do not modify GUI
			therefore, can be called from other threads
		also, if they do modify GUI
			these methods post window messages
	should there be different db models for sync and processing?
		no, they return the same data types
	should there be different db instances for sync and processing?
		each instance with its own connection
		each with its own caching, if needed
		seems like a good idea
	so, how should last used notebook be returned?
		stored as a name-value pair
		db passes a notebook object to the user model
		the user model passes it to the presenter
		the presenter processes it
		maybe creates some new object for a view
		the point is, db access is single-threaded
		so the database can return a pointer
			there is always at least one notebook
			there is always a default notebook
			the pointer should never be null
		if the pointer is never null, it can be a reference
		the class member can be a pointer
			assert not null before returning the reference
threading
	I don't want to implement threading right away
	but threading should be easy to add later on
	the threading model is dictated by sqlite and htmlayout
	each db instance represents a db connection
	access to each db instance is single-threaded
	all ui should be single-threaded
	we therefore have a ui thread and a thread per db instance
	ui thread
		signals from ui create data thread tasks
			presenters handles this
		ui getters send messages
			ui handles this
			sending on the same thread does not lock
			signal handlers from data threads should avoid getters
		ui setters post messages
			ui handles this
	data thread
		one per db instance
		should then be implemented in the db
		the db should have a message pump
	want to avoid bothering with messaging and tasks for now
database
	when should it be initialized?
		when it is being created
			check if the database is empty
			check for the properties table
		in future, when converting an old format
	how should it be initialized?
		assuming it is empty
		create tables
			properties
				version
				user name
				last used notebook
				default notebook
			notes
mobile testing
	need simple alternative to boost::test
	can copy stuff
	how can I implement AUTO_TEST_CASE?
		create a function taking a Test parameter
		add a pointer to the function to some global list
			how?
		create a base that adds itself to the global list on construction
		create test case classes that inherit from the base
		create a static instance of every such class
identity
	notebooks are identified by GUID
		but also have unique names
	unsynced notebooks have no GUID
	therefore, names are the real identifier
	what about notes?
	they don't have unique names
	when I want to open a note, a have to refer to it by some id
		by GUID
	therefore, notes need to have GUIDs
	maybe notebooks should have GUIDs too, then
	they can be assigned GUIDs automatically between syncs
	these would be replaced by server's GUIDs after sync
		views would have to be updated after sync completes
	also, the DOM elements need a GUID attribute
sync update
	GUIDs change after sync
		and possibly other fields
	if the note list is being displayed
		the query should be repeated
	if a note is being displayed
		it should be fetched from the database again
		deleted if absent
		but how, if it's GUID is old
		need a map from old GUIDs to new
	if a note is being edited
		TODO
mobile testing exceptions
	are often not caught
		fixed
	also need to test for exceptions
		done
mobile testing fixtures
	setting up the database every time is taking up space
	need two different classes
		global one to register the test
		local one to be created with a  fixture
UTF8 strings
	vector<unsigned char> is a bad container
	can't get a pointer when empty
	can add checks for empty vectors
data store initialization
	sqlite3_open_v2 creates a database that is either
		has no version
		has lesser version
		has greater version
		has correct version
	it is better not to try handling invalid databases
		what about db creation errors?
			up to ACID to handle
note import
	EnImporter needs to allocate notes
	no need to have them live outside OnImport handler
	options
		create EnImporter locally
			- can't use an interface, then
		have EnImporter use outside storage
			- different from DataStore
				maybe DataStore is the one that needs to change
				if it does not want notes to live between calls
		make EnImport clear its memory
			- extra call; might forget
SQLite wrapper
	need to destroy statements automatically
note list design
	need to set overflow for titles etc
		done
data interface revamp
	is there a need for INote, INotebook, ITimestamp, or ITag?
		they contain no complicated logic that might need to be mocked
		removing them would cut down the number of classes by 12
		what if I decided to add complicated logic later?
			like, connect them to the database
			seems like a bad idea even without the class overhead
	how should these objects be passed around?
		constraints
			avoid copies
				create a list of content
				pass it to the end consumer
				without caching
			single-threaded
			notes can be imported
			note info used for note list display
			note info can be edited
			note content displayed occasionally
			note content can be edited
			can filter by tags
			can rename notebooks
			can change default notebook
			can change last used notebook
		note list view does not have to store notes
			can store query
		currently
			query database
			cache the result in the note list model
			get results from this cache for the view
		alternatively
			store query in the note list model
			query database by note list model
			pass results directly to the view
		database queries can be stored by either value or pointer
			std::vector or boost::ptr_vector
			we no longer use interfaces for data
			so, no use for ptr_vector
		implementation
			database query functions return (const vector &)
			note list model returns (const vector &)
				where does it get it from?
				can either get it directly from user model
				or cache it
					can store the reference
						can't switch references
						store a pointer
					but then initialize it with an empty
					have to store the empty, as well, then
					good for resetting, actually
			presenters iterate through vectors
			view functions add entries one by one
	user model / data store split
		right now, they have almost identical interfaces
		a database is per-user
		user model controls database lifetime
		user model contains the database object
		separate user model would be used for sync
			with separate database connection 
			with read-write rights
			except, no use in creating a new database for sync
				so, different loading policies
		maybe data store should be a thinner sqlite3_db wrapper
			with a statement wrapper, as well
				RAII
				lazy parsing
		then user model should allocate a database and statements
			then call statements as needed
		thin database and statement wrappers are easier to test
			user model can then be properly tested on PC
			also avoiding untested private methods
database use testing
	mock database can't evaluate SQL
	might be better to just use the real database
	then I will need a real database whenever I involve UserModel
		for almost all tests, that is
	but, no; I can use MockUserModel instead
	test only UserModel itself with the mobile test suite
full-text search
	don't want to store raw note bodies in the FTS table
	because they contain tags and other stuff we don't want to search on
	even title, actually, might contain special markup
	should store originals in the note table
	should store stripped text in the FTS table
note view class design
	constraints
		modal
		create note view as child of note list view
		subscribe presenters to note view events
			presenter initialized after view
		might want to cache data for the view
			including window
		should not expose window-specific things in interface
menu bar handling
	constraints
		sends commands to a specific window
		is a top level window
		should have different buttons for different active windows
note resources
	requirements
		render pictures
		play audio
		attach files, audio, and pictures
		search images
	constraints
		identified in note contents by hash
		zero to many resources per note
		has MIME format
		has format-specific fields
		has recognition data
		has zero or more attributes
	choices
		one class with all necessary fields
		multiple classes
			common interface
			no common interface
	one class scenario is wasteful
	would also add unecessary logic
	multiple class scenario seems better
	no need for common interface
	there are few common operations with resources
exception testing
	requirements
		test that exception of the given type is thrown
		test a specified predicate on the exception
	plan
		take the statement
		give it catch of the specified type
			check the predicate there
		give it an ellipsis catch
			report an error
note resource handling
	requirements
		should be handled by NoteView
		others should be handled by HTMLayoutWindow
	HTMLayout gets requests through notification subscription
	can make the function virtual
	ask the descendant to call the base implementation
	there are several ways to fufill data requests
		send a signal with a blob reference
			- new type of signal required
			+ can protect against multiple providers
				by only letting one connect
		send a signal, provide blob setter
			- does not protect against multiple providers
			- non-local data storage
		a data loader object
			+ guarantees retrieval
			- introduces model dependcy
	special signal seems like the least of evils
	the lack of good choices is due to the immediacy of data loading
	the function has to return LOAD_OK right away
note resource storage
	requirements
		data should be available while it is loaded
		data for more than one note might be needed for one view
			for transitions
	data should be stored by the presenter
	does it?
	if it only needs to be available during loading, storage in view is enough
kinetic scrolling
	basic premise
		play scrolling animation
		mouse drag creates impulse
		friction reduces impulse
		animation stops when impulse vanishes
	animation
		similar to a game loop
		scroll continuously on idle
	state
		idle
			mouse down, move beyond threshold => dragging
		animating
			mouse down => dragging
			velocity drops below threshold => idle
		dragging
			mouse up => animating
				set velocity
		refactoring
			does it make sense to handle animation in another class?
				math
				state management
				make explicit data needed for state transitions
			interface
				SetStateAnimating
				SetStateDragging
				SetStateRefactoring
				GetState
				GetDistance(time)
			dragging and animation are fairly separate, though
			dragging is strongly tied to message processing
event subscription
	applications
		window subscrption to button clicks and selection changes
			call void() function in response to event
		kinetic scrolling animation
			scroll control in response to mouse events from it
		note flick animation
			repaint note view in response to mouse events from it
	requirements
		bind to specific elements
		bind by selector
		subscribe with the correct parameters
		subscribe member functions
	handler signatures my differ
	can create adapter functions
		that will convert parameters and call the given handler
		of a given object
	but the function pointer would require the subscriber's specific type
	how does boost::signal solve this problem?
		takes a slot_type reference
		slot_type is an object
	how does SWL handle this problem?
		creates a static proxy for each object type and message id
		supplies specialized message parameter object
	we have two scenarios
		one object handles behaviour events from multiple elements
		one object hnaldes miscellaneous events form one element
	it makes sense to keep the old system for the first scnenario
	subscribe event_handler obects for the second
	why oh why did I not stop at this point?
animation
	two message loop modes
		static
			GetMessage
			check for a "start animating" message
		animation
			PeekMessage
			repeatedly call animation functions while idle
	animation class
		provides
			flag for stopping animation
			step frame function that runs some animation
			methods to subscribe and unsubscribe animation functions
note preview
	want to display the thumbnails in note list
	have to insert the <img /> tag into the note html
	add a LoadingData handler to NotePresenter
	where to get the image data from?
		generate on the fly or pull from the database
		database storage can't be permanent
		because format may change
		although, this can also be made part of the data format
		except, we may decide to change format based on screen orientation
		even if it seems like a bad idea at the moment
	how to generate the data?
		HTMLayoutRender
			takes window handle, bitmap, and rectangle
			should use native format (16bpp)
		does it render to bitmap area or to window client area?
			client area
		how can I load HBITMAP data?
			could implement an event handler with on_draw
			seems like the way to do it
			also answers the question of whether caching is necessary
			if I draw, then it is
		so, the general idea is
			note list presenter
				clear title and subtitle
				set note body
				render to an HBITMAP array
				set the index as an attribute
			note list view
				subscribe to draw events from the newly added notes
				in handler, get the index attribute
				signal for HBITMAP with given index
				draw using the returned handle
		now both note and note list presenters are handling note list changes
		but if images are cached in the database
		then note list presenter will need to pull them
			to avoid making unnecessary queries
		actually, the note window would be creating the bitmap initially
			Render(HTBITMAP & bmp)
		then note list presenter needs access to note view
	implementation
		√ get HBITMAP drawing working
		add rendering
		add caching
	note view does not exist when notes are initially loaded
		on note list view creation
	note view is required for preview rendering
	therefore notes should be loaded after both views are created
	maybe main should initiate user loading manually
	image creation
		there seems to be no way of getting the bits
		CreateDIBSection hands out the pointer
		Imaging library can be used for processing
sync
	when sync connects to EN, the password might be rejected
	then sync brings up the signin window to get a new password
	two ways to proceed
		modal
			spin a new message loop in the signin window
			return control to sync when finished
		non-modal
			generate a request event and suspend sync
			generate a completion event and resume sync
	keep in mind that sync is in a separate thread
		any signals it sends are processed on its own thread
		sync has a separate user model with a separate db connection
		we don't want 2 UI threads
			so sync needs to display the dialog on the UI thread
		2 ways to run code on the UI thread
			window messaging
			main message loop augmentation
	general scenario
		sync does its own thing
		UI does its own thing
		sync gets in trouble, asks UI for some data, goes to sleep
		UI interacts with the user, gets sync its data, resumes it
	how to enable this
		the presenter would interact with sync's user data
			under assumption that sync is sleeping
		sync cannot signal an event directly
			has to leave some sort of message
	SyncModel
		presenters subscribe to events
			standard Connect methods
		sync calls method SetCredentials and blocks
		message pump calls Process, which signals events
		presenters modify sync's credentials model
		finishing the event unblocks sync
	lets look at it from another side
		sync starts with user credentials and runs until either
			it runs to completion
			the credentials are rejected
			some other error occurs
		sync starts when
			the sync button is pressed
			invalid user credentials are updated
		this no longer looks like a parallel thread
			rather like a worker thread
	SyncModel
		Sync method
			starts a new thread
			runs sync to one of the termination conditions
			if credentials are needed
				posts the appropriate message
					PostThreadMessage
				message loop asks it to dispatch the message
		DispatchMessage
			if sees the message sent by Sync
				raises the credentials.Updating event
				checks whether credentials were set
				restarts sync, if they were
	too much logic inside the model
	need to split this into a model and a controller
	SyncController
		initiates and controls sync
		displays credentials requests
	SyncPresenter
		runs the Sync method
		posts events to the window message queue
	instead of using Windows messaging, SyncModel can have its own
	much of the syncing code would be in EnService
	how much?
		download/upload notes, notebooks, resources
signin
	two sources
		sync needs new credentials
		anonymous user conversion
	what kind of presenters do they call for?
		UserSigninPresenter
			subscribes to NoteListView.SignIn
			updates current user's credentials
			converts the user to a named one
		SyncSigninPresenter
			subscribes to SyncModel.NeedCredentials
			updates the sync user's credentials
			restarts sync
		could sync and main user models end up with different credentials?
			do not cache them, but store in the database
	should signin update the user's credentials?
	after all, it is not his credentials that are set, but the next user's
	what to call these credentials?
		newCredentials
thumbnailer
	overview
		takes an HTMLayout window handle and a thumbnail size
		creates a window-sized DIB
		renders the window into the DIB
		creates an image object
		resizes it to thumbnail size
		creates a memory stream
		encodes the image as a jpg into it
	the imaging API is much too complex
	lets try using the graphin library
		jpg support not compiled
	JPEG options
		Imaging
			complicated
		libjpeg
			complicated
		graphin hack
			might be impossible
	went with the Imaging option — it works
	the note view shoud hide its UI when not shown
		TODO
	error handling needs testing
		TODO
thumbnail storage
	store the thumbnail with the other note data
	record the size, to update, if size requirements change
	retrieve the thumbnail with the note guid
	check the retrieved thumbnail size
	if different, replace the thumbnail
anonymous user
	now called [anonymous]
	disallow signing in with this username
		done
	add a test for this
		done
user management
	right now, the Evernote credentials are used for user's credentials
	what if I decide to add support for another note service, such as OneNote?
	then things become much more complciated, so lets not do that
	if I decide to switch from Evernote to OneNote, there would be no problem
	what about passwords?
	do I store the password for the last user only, or for all users?
	when a user signs in, he has to enter the password
	so there is no use in storing it
	what if the user logs out accidentally and has no access to network?
	he should be allowed to log back in
	so we don't check password on login
	however, sync needs the password
	it is better to get it from the database
sync
	must be capable of full sync and incremental sync
	full sync = clear clean records from db, then perform incremental sync
	implementation plan
		UI
			sync button
		user management
			last user
			credentials storage
		data model
			transactions
		threading model
			sync thread spawning
			sync result processing
				can skip the signin requesting for now
		download headers
			clear database
			authenticate
			getSyncChunc with afterUSN=0
			getNote
		full download
			download resources
		sync
			implement generic negotiation logic
			apply it to tags, notebooks, notes
credentials
	user credentials should be fetched from the database, not cached
		username and password in a single transaction
	new credentials should be cached
	there is no need to subscribe to user credentials updates
	so, we can create a POD credentials object
transactions
	which operations are performed with UserModel?
		EnImportPresenter::OnImport
			get last used notebook
			add a bunch of notes
			add a bunch of resources
			retrieve the notebook notes
		NoteListPresenter::OnLoadThumbnail
			get thumbnail
			set the thumbnail
		NoteListPresenter::OnUserLoaded
			get all notebooks
			get last used notebook
			retrieve the notebook notes
			get credentials
		NotePresenter::OnLoadingData
			get an image resource
		NotePresenter::OnOpenNote
			get a note body
			get a note
		SearchPresenter::ResetNotes
			get last used notebook
			retrieve the notebook notes
		SearchPresenter::SearchNotes
			get last used notebook
			retrieve the notebook notes
		UserLoader::Save
			get credentials
		UserSignInPresenter::OnCredentialsUpdated
			load
			set credentials
		UserSignInPresenter::OnSignIn
			get credentials
	transactions clearly have to be handled outside UserModel
		need to create RAII transaction objects
	imortantly, how to test transactions?
		have to create two UserModel instances
		the instances have to access the database concurrently
		on different threads
		have to make sure the database blocks properly
		one thread needs to
			enter a transaction
			make a write
			spin off another thread
		the second thread needs to
			enter a transaction
			try to make a write
		the first thread needs to
			make sure the second thread is blocked
EnService sync interface
	tasks
		download notebooks
		download notes
		download resources
	no, wait, server state is retrieved in chunks
	therefore we can't make separate requests like this
	tasks
		download state
		download resources
	both the client and the server can change during synchronization
	what we want to do is
		download the data at the moment of sync
		minus those pieces that are deleted during sync
empty notes
	occur during partial sync
	can either
		show them somehow specially
		not show
	the latter option is preferrable
		fewer user distractions
		less program logic
	better yet, don't commit empty notes
an unhandled exception is raised at startup
	the "Database could not be loaded." exception
	fixed
notes are not synced until I click anywhere
	because sync messages are only processed after windows messages
	if no windows message arrives, sync waits
	solutions
		send windows messages
		wake up the thread on sending
layout problem
	menu moves if I click before notes appear
	the body keeps its size
	the window keeps its size
	list view mouse handlers play no role
	the culprit is the hiding of the profile name
	how about we do not hide it?
	but instead set it to some neutral string
	after all, even the anonymous user might want to see some profile info
note images
	only the last image is displayed
	because of the way caching works
	cache all the images
	clear the cache when the page clears
	actually, this might not be the problem
	need to convert gif images to png
		no, the base64 decoder was incorrect
		need to add a test for trailing newline
		done
	now, there is an encoding problem
resource upload
	need to return several pieces of information for each
		data
		hash
		mime
	also, it would be better to copy to the final array right away
	TODO
sync logic
	want a separate component
		that will make decisions to follow
	full sync
		logic
			if remote, not local
				add local
			if remote, local conflict
				if dirty
					merge
				else
					rename local
			if local, not remote
				if dirty
					upload
				else
					delete
			if remote and local
				if same USN and clean
					do nothing
				if same USN and dirty
					upload
				if remote USN higher and clean
					replace with remote
				if remote USN higher and dirty
					merge
		data
			remote: availability, GUID, USN
			local: availability, GUID, USN, dirty flag
		decisions
			add
			merge
			rename
			upload
			delete
			do nothing
	incremental sync
		logic
			if remote, not local
				add local
			if remote, local conflict
				if dirty
					merge
				else
					rename local
			if local and remote
				if dirty
					merge
				else
					replace with remote
	difference between full sync and incremental
		starting USN
		same USN handling
	EnService should contain as little logic as possible
		factor it out later
		TODO
	SyncLogic usage
		build the remote resource list
		build the local resource list
		process remote-only, local-only, and conflicting
	resources to sync
		notes
		tags
		notebooks
	resource list building
		identity via guid
		build full local and remote lists
		build a guid set for each of the lists
		traverse each list
			checking the guid sets
			calling the appropriate sync function
	data types
		locally, we have Note, Notebook, and Tag classes
		each has a GetGuid method
		EnService could return same classes
		the classes then also need to have GetUsn and IsDirty methods
	need to know which notebook to upload a note to
		should sync by notebook
		then I can set the notebook for the whole NoteProcessor
	this ad-hoc "getting it to run" approach results is messy
		suspect much wasted effort
	need to refactor EnService
		should provide only basic services
			login requires credential verification
			SyncModel needs to fetch remote resource lists
			SyncLogic performs the following operations
				Add(remote)
				Delete(local)
				Rename(local)
				Upload(local)
				Merge(local, remote)
			note addition entails resource download
			uploading entails local note replacement
		this requires the following 
			CheckCredentials
			ListEntities
			DownloadNoteResources
			UploadNote
			UploadNotebook
			UploadTag
		many of these operations are interdependent
			sync resources determine what gets downloaded and uploaded
			need to upload and download notebooks and tags before notes
		there should be a minimum of logic in EnService
		it should be a dumb adapter between app logic and EN API
			it should handle EN exceptions
		EN works by sessions, therefore EnService has to expose sessions
			can expose user store and note store sessions
	sketch
		EnService
			GetUserStore
			GetNoteStore
			UserStore
				GetAuthenticationToken
			NoteStore
				ListEntities
				DownloadNoteResources
				UploadNote
				UploadNotebook
				UploadTag
	exceptions
		maybe EnService should catch exceptions and return error codes
		to avoid building CheckCredentials logic on exceptions
		if the stores are RAII objects, then they cannot be returned
		overall, connection problems are entirely expected
		adding an error handler for broken connection is another alternative
		we don't want to keep working with a store, if the connection is lost
		so, throw on connection lost
		GetAuthenticationToken should return an error message
	sync sequence
		tags and notebooks are independent
		they get synced first
		we only want to sync notes in the current notebook
		however, the current notebook might not exist on the server
		it might even get deleted
			ohi, sync dis notebook plz
			nowai! i deletd it
		in such a case, deleting the notebook is all that's needed
		if the notebook did not exist and was uploaded, populate it
		in either case, the remote note list will be empty
		how do I find out that the current notebook was deleted?
			in such a case, lastusednotebook should return the default
		do I need to find this out?
			if  the notebook is deleted, the remote note list is empty
			the local note list is also empty
			syncing is then a NOP
			as long as I get the current notebook before deleting it
	note resources
		once a decision to add a note is made, its data needs fetching
		getNoteContent requires note Guid — easy
		getResource requires data Guid
			these are not stored in our Note classes
			this is the only place in which they are needed
			so, it does not make sense to add them to the Note class
			could add a class to package note with resources
			peform sync logic on that
			what to call it?
				NoteWithResources
				EnNote
				TransferNote
				NotePackage
			something to say that it includes everything for EN interop
				EnInteropNote
		upload requires several pieces of information
			data
			guid
			mime format
			hash
		need more sophisticated resource objects
			blobs not sufficient
		this could be useful in other places, too
		these would be large imuutable objects
			do they really have to be immutable?
			what if I want to dither a bitmap before rendering it?
			I am not sharing it with anyone, if I hold the memory
		need to return them via shared pointers or pointer arrays
			is there another way?
			want to avoid reference counting and memory allocations
immutable class storage
	returning an immutable class copies it
	an immutable parameter cannot be initialized via reference
		because it is constracted before function call
	this means that these can only be returned by reference
	would like to have a class that is mutable until fully constructed
errors
	smileys do not show up
	thumbnails do not scale
	an unnamed database is created
